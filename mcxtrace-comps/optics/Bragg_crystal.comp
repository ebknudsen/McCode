 /*******************************************************************************
 *
 * McXtrace, X-ray tracing package
 *         Copyright, All rights reserved
 *         Risoe National Laboratory, Roskilde, Denmark
 *         Institut Laue Langevin, Grenoble, France
 *         University of Copenhagen, Copenhagen, Denmark
 *
 * Component: Bragg_crystal
 * 
 * %I
 * Written by: Marcus H Mendenhall, NIST <marcus.mendenhall@nist.gov>
 * Based on: Perfect_crystal.comp written by Anette Vickery, Andrea Prodi, Erik Knudsen
 * Date: December 1, 2016
 * Version: 2.1
 * Release: McXtrace 1.4
 * Origin: Marcus H. Mendenhall, NIST, Gaithersburg, MD, USA
 *
 * Perfect, reflecting crystal with common cubic structures (diamond, fcc, or bcc, and others if symmetry form factor multipliers provided explicitly)
 *
 * %D
 * Bragg_crystal.comp supercedes Perfect_Crystal.comp with major edits and corrections.
 *
 * Reads atomic formfactors from a data input file.
 * The PerfectCrystal code reflects ray in an ideal geometry, does not include surface imperfections or mosaicity
 *
 * The crystal is positioned such that the long axis of the crystal surface coincides with
 * z-axis. The angle between the Bragg planes and the crystal surface is alpha
 * Off-axis rays fixed June 2015 so axial divergence corrections are right
 * Inclusion of polarization and temperature dependence (via Debye-Waller factor), June-September 2015
 * Errors in complex arithmetic in DarwinReflectivity2 corrected, September 2015, MHM
 * Symmetries for form factors corrected 20150924
 * Rotation code updated to use exact DarwinReflectivity Theta0, Thetah so answer is right even if alpha != 0. 20151009 MHM
 *
 * This code has been validated against both experimental data
 * (2 channel-cut 3-bounce Si 440 crystals together in non-dispersive mode, at Cu kalpha)
 * and against theoretical rocking rocking curves from XOP for Si220 at Sc kalpha and Si440 at Cu kalpha.
 * 
 * Changelog:  
 * December 1, 2016:  results for (1,1,1) etc. with complex form factor made to agree with XOP
 *
 * Notation follows Tadashi Matsushita and Hiro-O Hashizume, X-RAY MONOCHROMATORS. Handbook on Synchrotron Radiation,North-Holland Publishing Company, 1:263–274, 1983.
 * 
 * Non-copyright notice:
 * Contributed by the National Institute of Standards and Technology; not subject to copyright in the United States. 
 * This is not an official contribution, in that the results are in no way certified by NIST.
 *
 * %P
 * INPUT PARAMETERS
 * length: [m] 			length of the crystal (along z-axis)
 * width: [m] 			width of the crystal (along x-axis)
 * material: [ ]			Si, Ge (maybe also GaAs?)
 * V: [Å^3]			unit cell volume
 * h: [ ]                          Miller index of reflection
 * k: [ ]                          Miller index of reflection
 * l: [ ]                          Miller index of reflection
 * alpha: [rad]		 	asymmetry angle (alpha=0 for symmetric reflection, ie the Bragg planes are parallel to the crystal surface)
 * R0: [ ]                         Reflectivity. Overrides the computed Darwin reflectivity. Probably only useful for debugging.
 * debye_waller_B: [Å^2]	Debye-Waller temperature factor, M=B*(sin(theta)/lambda)^2*(2/3), default=silicon at room temp.
 * crystal_type: [ ]
 *  Bragg_crystal_explicit: provide explicit real and imaginary form factor multipliers structure_factor_scale_r, structure_factor_scale_i
 *  Bragg_crystal_diamond: diamond
 *  Bragg_crystal_fcc: fcc
 *  Bragg_crystal_fcc: bcc
 *
 * %E
 *******************************************************************************/

DEFINE COMPONENT Bragg_crystal
DEFINITION PARAMETERS ()
SETTING PARAMETERS (length=0.05, width=0.02, V=160.1826, string form_factors="FormFactors.txt", string material="Si.txt", alpha=0.0,
  R0=0, debye_waller_B=0.4632, int crystal_type=1, int h=1, int k=1, int l=1 ,
    structure_factor_scale_r=0.0, structure_factor_scale_i=0.0)
OUTPUT PARAMETERS (prms)
/* X-ray parameters: (x,y,z,kx,ky,kz,phi,t,Ex,Ey,Ez,p) */

SHARE
%{
#ifndef MXBRAGG_CRYSTALS
#define MXBRAGG_CRYSTALS 1

enum {Bragg_crystal_explicit=0, Bragg_crystal_diamond, Bragg_crystal_fcc, Bragg_crystal_bcc};

/* make proper function declaration to be standards-compliant */
void MxBragg_DarwinReflectivity(double *R, double *Thetah, double *Theta0, double *DeltaTheta0,
                         double f00, double f0h, double fp, double fpp, double V, double alpha, int h, int k, int l,
                         double debye_waller_B, double E, double Thetain, int pol,
                        int crystal_type, double fscaler, double fscalei
                         );

    %include "read_table-lib"
#include <complex.h>
    /* something that would be relevant for ALL crystals */
    void MxBragg_DarwinReflectivity(double *R, double *Thetah, double *Theta0, double *DeltaTheta0,
                             double f00, double f0h, double fp, double fpp, double V, double alpha, int h, int k, int l,
                             double debye_waller_B, double E, double Thetain, int pol,
                            int crystal_type, double fscaler, double fscalei
                             )
    {
        
        double lambda,theta,theta0,DeltaThetas,a,d,b,C,W,kappa,g,L;
        double F0r,F0i,Fhr,Fhi,psi0r,psi0i,psihr,psihi;
        
        lambda = 2*PI/(E2K*E);  			/* wavelength in Å, E in keV, using built-in constants for safety    */
        a = cbrt(V); 				/* side length of unit cubic cell (Å)*/
        d = a/sqrt(h*h + k*k + l*l); 		/* d-spacing (Å)*/
        theta = asin(lambda/(2*d));  		/* kinematical bragg angle (rad) */
        b = sin(theta + alpha)/sin(theta - alpha);  /* asymmetry factor */
        
        *Theta0 = Thetain - alpha; 			/* (rad) angle between Bragg planes and incident ray */
        *Thetah = b*(*Theta0 - theta) + theta;   	/* (rad) Angle between Bragg planes and reflected ray */
        /*check if Bragg angle is less than alpha. If so return 0 reflectivity*/
        if (theta<alpha) {
            *R=0;
            *DeltaTheta0 = -1; /*to mark it irrelevant*/
        }
        
        /* Define polarization factor: */
        switch(pol){
            case 0:
                C = (1 + fabs(cos(2*theta)))/2;         	/* unpolarized */
                break;
            case 1:
                C = fabs(cos(2*theta));  		/* polarization in the scattering plane */
                break;
            case 2:
                C = 1;                          	/* polarization perpendicular to the scattering plane*/
                break;
        }
        
        /* structure factor rules from:
            https://en.wikipedia.org/wiki/Structure_factor section on diamond cubic crystals
        */

        switch(crystal_type) {
            case Bragg_crystal_explicit:
                /* use explicitly provided structure factor scale factor */
                break;
            case Bragg_crystal_diamond: /* diamond lattice rules */
                if (((h+k+l)%2) != 0){ 		/* (111) etc. odd sum eflection */
                    fscaler=fscalei=4.0;
                }
                else if (((h+k+l)%4)==0){ 		/* (400) etc. h+k+l=4n reflection */
                    fscaler=8; fscalei=0;
                } else {
                    /* any other reflection is forbidden, will get a divide-by-zero somewhere, but user is
                        responsible for only using allowed reflections */
                    fscaler=0; fscalei=0;
                }
                break;
            case Bragg_crystal_fcc: /* fcc lattice rules */
                {
                    int hpar=h%2, kpar=k%2, lpar=l%2;
                    if ( hpar==kpar && kpar==lpar ) { /* all parities the same */
                        fscaler=4.0; fscalei=0.0;
                    }
                    else { 		/* mixed parity forbidden */
                        fscaler=0; fscalei=0;
                    }
                }
                break;
            case Bragg_crystal_bcc: /* bcc lattice rules */
                if ( ((h+k+l)%2) == 0 ) { /* h+k+l even */
                    fscaler=2.0; fscalei=0.0;
                }
                else { 		/* otherwise forbidden */
                    fscaler=0; fscalei=0;
                }
                break;
           default:
                fscaler=0; fscalei=0; /* fail later if unknown crystal type */
                break;
        }

        F0r=8*(f00+fp);
        F0i=8*fpp;
        double scalemag=sqrt(fscaler*fscaler+fscalei*fscalei);
        Fhr=scalemag*(f0h+fp);
        Fhi=scalemag*fpp;

        double main_scale=RE*lambda*lambda/(PI*V);
        double M=debye_waller_B*SQR(sin(Thetain)/lambda)*(2./3.); /* temperature factor */
        psi0r = F0r*main_scale;
        psi0i = F0i*main_scale;
        psihr = Fhr*main_scale*exp(-M); /* Eq 23*/
        psihi = Fhi*main_scale*exp(-M); /* only angle-dependent part gets scaled by temp factor */
        
        W = 0.5 * (sqrt(b) + 1/sqrt(b)) * psi0r/(C * psihr) +  sqrt(b)*sin(2*theta)*(theta - *Theta0)/(C * psihr); /* eq 28*/
        kappa = psihi/psihr;                                              	/* eq 22 */
        g = 0.5*(sqrt(b) + 1/sqrt(b))*psi0i/(C*psihr);               	/* eq 21 */
        L = (1/(1 + kappa*kappa))*( W*W + g*g + sqrt(SQR(W*W - g*g - 1 + kappa*kappa) + 4*SQR(g*W - kappa)));
        
        /* *R = L - sqrt(L*L - 1); */
        /* replace x-sqrt(x^2-1) with exactly equal 1/(x+sqrt(x^2-1)) to avoid roundoff when x is large ... MHM */
        *R = 1/(L + sqrt(L*L - 1));
        
        DeltaThetas = psi0r/sin(2*theta);               	/* eq 32 */
#ifdef MCDEBUG
        printf("E,lambda= %f , %f \n",E,lambda);
        printf("theta= %f \n",theta*180/PI);
        printf("Theta0, Thetah= %f %f \n",*Theta0*180/PI,*Thetah*180/PI);
        printf("theta = %g rad, alpha=%g rad.\n",theta,alpha);
        printf("b,sqrt(b)= %f %f\n",b,sqrt(b));
        printf("1/sqrt(b)= %f \n",1/sqrt(b));
        printf("Fhr, Fhi, F0r, F0i= %g %g %g %g\n",Fhr, Fhi, F0r, F0i);
        printf("psihr, psihi, psi0r, psi0i= %g %g %g %g\n",psihr, psihi, psi0r, psi0i);
        printf("sqrt(b)*sin(2*theta)= %g \n",sqrt(b)*sin(2*theta));
        printf("C, pis0r,C * psihr= %g %g %g\n",C, psi0r,C * psihr);
        printf("W= %f \n",W);
        printf("kappa= %f \n",kappa);
        printf("g= %f \n",g);
        printf("L= %f \n",L);
        printf("R= %f \n",*R);
        printf("DeltaThetas %f \n",3600*DeltaThetas*180/PI);
#endif
        *DeltaTheta0 = 0.5*(1 + 1/b)*DeltaThetas;                        	/* center of reflectivity curve is at theta + DeltaTheta0 eq 31 */
    }
#endif /* MXBRAGG_CRYSTALS */
%}

DECLARE
%{
    struct {
        int Z;
        double rho,At,f_rel,f_nt;
        t_Table m_t;
        t_Table f0_t;
    } prms;
%}

INITIALIZE
%{
    int status;
    if (material){
        if ((status=Table_Read(&(prms.m_t),material,0))==-1){
            fprintf(stderr,"Error(%s): Could not parse file \"%s\"\n",NAME_CURRENT_COMP,material);
            exit(-1);
        }
        char **header_parsed;
        header_parsed=Table_ParseHeader(prms.m_t.header,"Z","A[r]","rho","Z/A","sigma[a]",NULL);
        if(header_parsed[2]){prms.rho=strtod(header_parsed[2],NULL);}
        if(header_parsed[0]){prms.Z=strtod(header_parsed[0],NULL);}
        if(header_parsed[1]){prms.At=strtod(header_parsed[1],NULL);}
    }else{
        fprintf(stderr,"Error(%s): No material file specified\n",NAME_CURRENT_COMP);
    }
    if(form_factors){
        if ((status=Table_Read(&(prms.f0_t),form_factors,0))==-1){
            fprintf(stderr,"Error(%s): Could not parse file \"%s\"\n",NAME_CURRENT_COMP,form_factors);
            exit(-1);
        }
    }
%}

TRACE
%{
    double E;				// (keV) x-ray energy
    double K; 				// length of k-vector
    double kxu,kyu,kzu;			// unit vector in the direction of k-vector.
    double tin;				// 'time' of intersection of ray with y=0 plane (which include the crystal surface)
    double x_int,y_int,z_int;		// intersection with the y=0 plane
    double dist;				// distance from position at t=0 to the y=0 plane
    double f00, f0h, fp, fpp;		// atomic form factors for Q=0 is (f00 + fp + i*fpp) and for Q= ha*+kb*+lc* it is (f0h + fp + i*fpp).
    double Thetain;			// (rad) angle between the crystal surface and the incident ray
    double Theta0;			// (rad) angle between the Bragg planes and the incident ray
    double Thetah;			// (rad) angle between the Bragg planes and the reflected ray
    double Thetaout;			// (rad) angle between the crystal surface and the reflected ray
    double DeltaTheta0;			// (rad) the center of the reflectivity curve is at asin(n*lambda/(2*d)) + DeltaTheta0
    double Rpi, Rsig, R;          // Reflectivity value calculated by DarwinReflectivity() function for each incoming photon
    
    /* get the photon's kvector and energy */
    K=sqrt(kx*kx+ky*ky+kz*kz);
    E = K2E*K; /* use built-in constants for consistency */
    /* make unit vector in the direction of k :*/
    kxu = kx; kyu = ky; kzu = kz;
    NORM(kxu,kyu,kzu);
    /* printf("incoming kx,ky,kz, Ex, Ey, Ez, k.E: %f %f %f %g %g %g %g\n", kx,ky,kz,Ex,Ey,Ez, kxu*Ex+kyu*Ey+kzu*Ez); */
    
    /*intersection calculation*/
    tin = -y/kyu;
    if (tin>=0){
        /* check whether our intersection lies within the boundaries of the crystal*/
        x_int=x+kxu*tin;
        y_int=y+kyu*tin;
        z_int=z+kzu*tin;
        
        if (fabs(x_int)<=width/2 && fabs(z_int)<=length/2){
            dist=sqrt(SQR(x-x_int)+SQR(y-y_int)+SQR(z-z_int));
            PROP_DL(dist); 			/* now the photon is on the crystal surface, ready to be reflected... */
            SCATTER;
            Thetain=fabs(asin(kyu)); /* k(x,y,z)u is a unit vector, the y component is sin(theta) */
            double d=cbrt(V)/(sqrt(h*h+k*k+l*l));/*this is valid only for cubic structures*/
            f00 = prms.Z;
            f0h = Table_Value(prms.f0_t,1/(2*d),prms.Z);
            fp  = Table_Value(prms.m_t,E,1)-prms.Z;
            fpp = Table_Value(prms.m_t,E,2);

            double alpha1=alpha;
            /* check for 3rd & 1st quadrant hits, backward hit from above or forward hit from below and reverse sense of alpha */
            if( (ky<0 && kz<0) || (ky>0 && kz>0) ) alpha1=-alpha1;
            MxBragg_DarwinReflectivity(&Rpi , &Thetah, &Theta0, &DeltaTheta0, f00, f0h, fp, fpp, V, alpha1, h, k, l,
                debye_waller_B, E, Thetain,1, crystal_type, structure_factor_scale_r, structure_factor_scale_i
            );
            MxBragg_DarwinReflectivity(&Rsig, &Thetah, &Theta0, &DeltaTheta0, f00, f0h, fp, fpp, V, alpha1, h, k, l,
                debye_waller_B, E, Thetain,2, crystal_type, structure_factor_scale_r, structure_factor_scale_i
            );

            double pi_x, pi_y, pi_z, sig_x, sig_y, sig_z;
            double kx0=kx, ky0=ky, kz0=kz, Ex0=Ex, Ey0=Ey, Ez0=Ez;

            /* sig_x,y,z is k(in) x surface_normal i.e. the direction of sigma polarization */
            vec_prod_func(&sig_x , &sig_y , &sig_z , kx0, ky0, kz0, 0, -1, 0);
            NORM(sig_x, sig_y, sig_z);
            /* pi is a vector perpendicular to k_in and sig i.e. the direction of pi polarization incoming */
            vec_prod_func(&pi_x, &pi_y, &pi_z, kx0, ky0, kz0, sig_x, sig_y, sig_z);
            NORM(pi_x , pi_y , pi_z );

#ifdef MCDEBUG
            printf("%s: Thetain: %.3f sigma: (%g, %g, %g) pi: (%g, %g, %g) \n", NAME_CURRENT_COMP,
                   Thetain*180/PI, sig_x, sig_y, sig_z, pi_x, pi_y, pi_z);
#endif

            double sth=sin(Theta0+Thetah), cth=cos(Theta0+Thetah);
            if(sig_x*pi_y*pi_z > 0) { /* backwards hit, rotate the other way */
                sth=-sth;
            }
            double sx2=sig_x*sig_x, sy2=sig_y*sig_y, sz2=sig_z*sig_z, r2=sig_x*sig_x+sig_y*sig_y;

            /* initialize a rotation matrix by the appropriate angle around the sigma axis, this from Mathematica RotationMatrix[] */
            double m[3][3]={
                sx2 + (cth*(sy2 + sx2*sz2))/r2,sig_x*sig_y - sig_z*sth + (cth*sig_x*sig_y*(-1 + sz2))/r2,sig_x*sig_z - cth*sig_x*sig_z + sig_y*sth,
                sig_x*sig_y + sig_z*sth + (cth*sig_x*sig_y*(-1 + sz2))/r2,sy2 + (cth*(sx2 + sy2*sz2))/r2,sig_y*sig_z - cth*sig_y*sig_z - sig_x*sth,
                sig_x*sig_z - cth*sig_x*sig_z - sig_y*sth,sig_y*sig_z - cth*sig_y*sig_z + sig_x*sth,cth*r2 + sz2
            };

#ifdef MCDEBUG
            printf("%s matrix=\n%12.3f %12.3f %12.3f\n%12.3f %12.3f %12.3f\n%12.3f %12.3f %12.3f\n", NAME_CURRENT_COMP,
                m[0][0],m[0][1],m[0][2],m[1][0],m[1][1],m[1][2],m[2][0],m[2][1],m[2][2]
            );
#endif

            /* execute the rotation about the sigma vector */
            kx=m[0][0]*kx0+m[0][1]*ky0+m[0][2]*kz0;
            ky=m[1][0]*kx0+m[1][1]*ky0+m[1][2]*kz0;
            kz=m[2][0]*kx0+m[2][1]*ky0+m[2][2]*kz0;

            /* resolve incoming polarization into sig and pi bits, and scale by sqrt(reflectivity) which is amplitude scale */
            double Esig=(Ex*sig_x+Ey*sig_y+Ez*sig_z), Epi=(Ex*pi_x+Ey*pi_y+Ez*pi_z);
            if(Esig==0 && Epi==0) { /* someone didn't set the polarization direction; set it now to a random value and it will propagate */
                double Phi=rand01()*PI/2;
                Esig=cos(Phi); Epi=sin(Phi);
            }
            Esig=Esig*sqrt(Rsig);
            Epi=Epi*sqrt(Rpi);
            R=Esig*Esig+Epi*Epi; /* projected reflectivity, squared back to intensity */

            /* pi is now a vector perpendicular to k_out and sig i.e. the direction of pi polarization outgoing */
            vec_prod_func(&pi_x, &pi_y, &pi_z, kx, ky, kz, sig_x, sig_y, sig_z);
            NORM(pi_x , pi_y , pi_z );

            /* a linear combination of these is still perpendicular to k, but has the correct polarization weighting */
            Ex=Epi*pi_x+Esig*sig_x;
            Ey=Epi*pi_y+Esig*sig_y;
            Ez=Epi*pi_z+Esig*sig_z;
            NORM(Ex, Ey, Ez);
#ifdef MCDEBUG
            printf("%s: Rsig, Rpi, R, k0, k1, e0, e1: %g %g %g (%g, %g, %g) (%g, %g, %g) (%g, %g, %g) (%g, %g, %g)\n", NAME_CURRENT_COMP,
                   Rsig,  Rpi, R,
                   kx0, ky0, kz0, kx, ky, kz, Ex0, Ey0, Ez0, Ex, Ey, Ez);
#endif
            /* apply Darwin reflectivity if not is supplied from outside*/
            if (!R0){
                p*=R;
            }else{
                p*=R0;
            }
            /*catch dead rays*/
            if (p==0) ABSORB;
        } else {
            RESTORE_XRAY(INDEX_CURRENT_COMP, x, y, z, kx, ky, kz, phi, t, Ex, Ey, Ez, p);
        }
    }
%}

MCDISPLAY
%{
    
    rectangle("xz",0,0,0,width,length);
%}

END
