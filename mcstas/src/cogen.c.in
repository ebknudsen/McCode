/*******************************************************************************
*
* McCode system component cogen.c.in:
* McStas/McXtrace, neutron/xray ray-tracing package
*         Copyright (C) 1997-2018, All rights reserved
*         DTU Physics, Kgs. Lyngby, Denmark
*	  Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*         Copenhagen University, Copenhagen, Denmark
*
* Kernel: cogen.c
*
* %Identification
* Written by: K.N.
* Modifed for X-rays by E.K.
* Date: Aug  20, 1997
* Origin: Risoe
* Release: McStas 1.6
* Version: $Revision$
*
* Code generation from instrument definition.
*
*******************************************************************************/

#include <stdarg.h>
#include <string.h>
#include <stdio.h>
#include "mccode.h"


/*******************************************************************************
* Some general comments on code generation.
*
* Code is output in the form of strings using the following functions:
*   cout();                        (one line at a time)
*   coutf();                       (with printf-style formatting)
*
* The type of numbers used in the generated code is given by the macro MCNUM
* (defined in mccode-r.h).
*
* A few letters occur in generated names to distinguish different kinds of
* identifiers (instrument parameters, component definition parameters, internal
* temporary variables and so on). Care must be takes to choose these letters
* such that no name clashes will occur with names generated by other parts of
* the code or generated from user symbols.
*
* Finally, names generated from user symbols are generally chosen to match
* the originals as closely as possible to make the generated code more
* readable (for debugging purposes).
*
* The following is a list of the identifiers generated in the output. The first
* column gives the identifier as it appears in the generated code, the second
* explains the origin of the identifier in the instrument definition source
* (if any).
*
* ip<PAR>        From instrument parameter <PAR>.
* init           Function containing initialization code.
* inputtable     Table of instrument parameters.
* NUMIPAR        Macro giving the number of instrument parameters.
* numipar        Global variable with the value of ##NUMIPAR.
* c<C>_<P>       From definition or setting parameter <P> in component
*                  instance <C>.
* posa<COMP>     Absolute position of coordinate system of <COMP>.
* posr<COMP>     Position of <COMP> relative to previous component.
* rota<COMP>     Absolute rotation.
* rotr<COMP>     Relative rotation.
* tc1            Temporary variable used to compute transformations.
* tc2
* tr1
* nx             Neutron state (position, velocity, time, and spin).
* ny             or Xray state (position, wavevector, phase, polarisation, and weight).
* nz
* nvx   nkx
* nvy   nky
* nvz   nkz
* nt    nphi
* nsx   nEx
* nsy   nEy
* nsz   nEz
* np
* absorb          label for ABSORB (goto)
* Scattered       Incremented each time a SCATTER is done
* Restore         Flag indicating that @MCCODE_PARTICLE@ should be restored
* NCounter        Incremented each time a @MCCODE_PARTICLE@ is entering the component
* AbsorbProp      single counter for removed events in PROP calls
* comp_storein    Positions of @MCCODE_PARTICLE@ entering each comp (loc. coords)
* Group<GROUP>    Flag true when in an active group
* sig_message     Message for the signal handler (debug/trace, sim status)
* JumpCounter     iteration counter for JUMP
*******************************************************************************/



/*******************************************************************************
* Generation of declarations.
*
* The following declarations are generated:
* 1. Header file #include - "mccode-r.h" for declarations for the
*    mcstas runtime.
* 2. Declarations of global variables to hold the values of the instrument
*    parameters. For example, for an instrument parameter OMM, the
*    declaration "MCNUM ipOMM;" is generated.
* 3. Declaration of a table ##inputtable containing the list of instrument
*    parameters. For each parameter, the name, a pointer to the
*    corresponding global variable, and the type (double, int,
*    string) is given. The macro NUMIPAR gives the number of
*    entries in the table and is also found as the value of the
*    variable numipar; in addition, the table is terminated by two
*    NULLs. This table is used to read the instrument parameters from
*    the user or from another program such as TASCOM.
* 4. User declarations copied verbatim from the instrument definition file.
* 5. Declarations for the component parameters. This uses #define for
*    definition parameters and global variables for setting parameters.
* X. User declarations from component definitions.
* X. Declarations of variables for coordinate system transformations.
* X. Declaration of variables for @MCCODE_PARTICLE@ state.
* X. Function prototypes.
*******************************************************************************/

/* PROJECT=1 for McStas, 2 for McXtrace. Now using @MCCODE_PARTICLE@ @MCCODE_NAME@ */
#ifndef MCCODE_PROJECT
#define MCCODE_PROJECT @MCCODE_PROJECT@
#endif

#ifndef MCCODE_LIBENV
#define MCCODE_LIBENV @MCCODE_LIBENV@
#endif

#ifndef MCCODE_PARTICLE
#define MCCODE_PARTICLE @MCCODE_PARTICLE@
#endif

/* Functions for outputting code. */

/* Handle for output file. */
static FILE *output_handle           = NULL;  /* Handle for output file. */
static int   num_next_output_line    = 1;     /* Line number for next output line. */
static char *quoted_output_file_name = NULL;  /* str_quote()'ed name
                                                 of output file. */

/* Convert instrument formal parameter type numbers to their enum name. */
char *instr_formal_type_names[] =
  { "instr_type_int", "instr_type_string", "instr_type_char", "instr_type_vector", "instr_type_double" };

/* 'char' and 'MCNUM' are for static array allocations */
char *instr_formal_type_names_real[] =
  { "long", "char*", "char", "MCNUM*", "MCNUM"};

/*******************************************************************************
* Output a single line of code
* Assumes that the output does not contain newlines.
*******************************************************************************/
static void
cout(char *s)
{
  fprintf(output_handle, "%s\n", s);
  num_next_output_line++;
}

/*******************************************************************************
* Output a single line of code using printf-style format string.
* Assumes that the output does not contain newlines.
*******************************************************************************/
static void
coutf(char *format, ...)
{
  va_list ap;

  va_start(ap, format);
  vfprintf(output_handle, format, ap);
  va_end(ap);
  fprintf(output_handle, "\n");
  num_next_output_line++;
}

/*******************************************************************************
* Output #line directive to handle code coming from a different file.
* The filename is assumed to be already properly quoted for special chars.
*******************************************************************************/
static void
code_set_source(char *filename, int linenum)
{
  if(linenum > 0)
    coutf("#line %d \"%s\"", linenum, filename);
}

/*******************************************************************************
* Output #line directive to reset back to the generated output C file.
*******************************************************************************/
static void
code_reset_source(void)
{
  /* Note: the number after #line refers to the line AFTER the directive. */
  coutf("#line %d \"%s\"", num_next_output_line + 1, quoted_output_file_name);
}

/*******************************************************************************
* Output a list of lines of code
*******************************************************************************/
static void
codeblock_out(struct code_block *code)
{
  List_handle liter;                /* For list iteration. */
  char *line;                        /* Single code line. */

  if(list_len(code->lines) <= 0)
    return;
  code_set_source(code->quoted_filename, code->linenum + 1);
  liter = list_iterate(code->lines);
  while(line = list_next(liter))
  {
    fprintf(output_handle, "%s", line);
    num_next_output_line++;
  }
  list_iterate_end(liter);
  code_reset_source();
}

/*******************************************************************************
* Output a list of lines of code, embraced in { ... }
*******************************************************************************/
static void
codeblock_out_brace(struct code_block *code)
{
  List_handle liter;                /* For list iteration. */
  char *line;                        /* Single code line. */

  if(list_len(code->lines) <= 0)
    return;
  code_set_source(code->quoted_filename, code->linenum);
  cout("{");
  liter = list_iterate(code->lines);
  while(line = list_next(liter))
  {
    fprintf(output_handle, "%s", line);
    num_next_output_line++;
  }
  list_iterate_end(liter);
  cout("}");
  code_reset_source();
}

/*******************************************************************************
* Create an empty code list
*******************************************************************************/
struct code_block *
codeblock_new(void)
{
  struct code_block *cb;

  palloc(cb);
  cb->filename = NULL;
  cb->quoted_filename = NULL;
  cb->linenum  = -1;
  cb->lines    = list_create();
  return cb;
}

/*******************************************************************************
* Read a file and output it to the generated simulation code. Uses a
* fixed-size buffer, and will silently and arbitrarily break long lines.
*******************************************************************************/
static void
embed_file(char *name)
{
  char buf[4096];
  FILE *f;
  int last;

  if (!symtab_lookup(lib_instances, name))
  {
    /* First look in the system directory. */
    f = open_file_search_sys(name);
    /* If not found, look in the full search path. */
    if(f == NULL) {
      f = open_file_search(name);
      /* If still not found, abort. */
      if(f == NULL)
        fatal_error("Could not find file '%s'\n", name);
      else if (verbose) fprintf(stderr, "Embedding file      %s (user path)\n", name);
    } else if (verbose) fprintf(stderr, "Embedding file      %s (%s)\n", name, get_sys_dir());

    cout("");
    code_set_source(name, 1);
    /* Now loop, reading lines and outputting them in the code. */
    while(!feof(f))
    {
      if(fgets(buf, 4096, f) == NULL)
        break;
      last = strlen(buf) - 1;
      if(last >= 0 && (buf[last] == '\n' || buf[last] == '\r'))
        buf[last--] = '\0';
      if(last >= 0 && (buf[last] == '\n' || buf[last] == '\r'))
        buf[last--] = '\0';
      cout(buf);
    }
    fclose(f);
    coutf("/* End of file \"%s\". */", name);
    cout("");
    code_reset_source();
    symtab_add(lib_instances, name, NULL);
  } /* else file has already been embedded */
} /* embed_file */

/* *****************************************************************************
* cogen_defundef: define/undefine a symbol from a List
* input:  a list
*         a flag: GLOBAL_INSTANCE_PAR_VALUE=define with component name,
*                 LOCAL_INSTANCE_PAR_VALUE =define with 'comp' as structure name,
*                 INSTRUMENT_PAR_VALUE     =define with 'instrument_name' as structure name
*                 GLOBAL_INSTANCE_PAR_REF  =define with component name pointer,
*                 PAR_UNDEF                =un-define
*
* code is generated in function [comp]_[section=init/save/finally/display]
* called by: cogen_comp_[section]
***************************************************************************** */
enum DEFINITION_TYPE {
  INSTRUMENT_PAR_VALUE,
  GLOBAL_INSTANCE_PAR_REF,
  LOCAL_INSTANCE_PAR_REF,
  PAR_UNDEF
};

static void cogen_defundef(struct comp_inst *comp, List l, char define_it)
{
  if(list_len(l) > 0) {
    List_handle liter;
    struct comp_iformal *c_formal;/* Name of component formal input parameter */

    liter = list_iterate(l);
    while(c_formal = list_next(liter)) {
      int flag_noconflict=1;

      if (!c_formal->id || !strlen(c_formal->id))
        continue; // skip invalid parameter names
      switch (define_it) {
      case GLOBAL_INSTANCE_PAR_REF:
        coutf("  #define %s (_%s->_parameters.%s)",
          c_formal->id, comp->name, c_formal->id);
        break;
      case LOCAL_INSTANCE_PAR_REF:
        coutf("  #define %s (comp->_parameters.%s)",
          c_formal->id, c_formal->id);
        break;
      case INSTRUMENT_PAR_VALUE:
        /* instrument parameters, only when no conflict with component */
        if (comp) {
          int index=0;
          for (index=0; index <3; index++) {
            List l;
            if (index ==0)      l = comp->def->set_par ;
            else if (index ==1) l = comp->def->out_par ;
            else                l = comp->def->def_par ;

            if(list_len(l) > 0)
            {
              List_handle liter = list_iterate(l);
              struct comp_iformal *ci_formal=NULL;/* Name of component formal input parameter */

              while(ci_formal = list_next(liter))
                if (!strcmp(c_formal->id, ci_formal->id)) {
                  flag_noconflict=0; break;
                }
            }
          } /* for List */
        }
        if (flag_noconflict && strlen(c_formal->id))
          coutf("  #define %s (instrument->_parameters._%s)",
            c_formal->id, c_formal->id);
        break;
      case PAR_UNDEF:
      default:
        coutf("  #undef %s", c_formal->id);

      } /* switch */
    } /* while */
    list_iterate_end(liter);
  }
} /* cogen_defundef */

/* *****************************************************************************
* cogen_comp_init_defpar: write the definition parameters in INIT
* input:  a component instance structure pointer (not modified)
*
* code is generated in function [comp]_init
* called by: cogen_comp_init
***************************************************************************** */
int cogen_comp_init_defpar(struct comp_inst *comp)
{
  int warnings=0;

  if(list_len(comp->def->def_par) > 0)
  {
    List_handle liter;                /* For list iteration. */

    liter = list_iterate(comp->def->def_par);
    struct comp_iformal *c_formal;/* Name of component formal input parameter */

    while(c_formal = list_next(liter))
    {
      struct Symtab_entry *entry = symtab_lookup(comp->defpar, c_formal->id);
      char                *val   = exp_tostring(entry->val);  /* replaced by instrument parameter when exsists */
      coutf("  #define %s %s", c_formal->id, val);
      if (c_formal->type == instr_type_string || c_formal->type == instr_type_vector)
      {
        /* a string definition parameter should be converted into a setting parameter to avoid e.g.
         * warning: format ‘%s’ expects type ‘char *’, but argument X has type ‘int’    */
        fprintf(stderr,"Warning: Component %s=%s(string or vector %s)\n"
                       "         DEFINITION parameter may be changed into a SETTING parameter\n"
                       "         File: %s\n",
        	comp->name, comp->def->name, c_formal->id, comp->def->source);
        warnings++;
		  }
      str_free(val);
    }
    list_iterate_end(liter);
  }

  return(warnings);
} /* cogen_comp_init_defpar */

/* *****************************************************************************
* cogen_comp_declare: write the declaration part from the component instance
*   that is the component parameter structure, with positioning stuff
* input:  a component instance structure pointer (not modified)
* output: number of warning/errors to fix.
*
* code is generated at root level of C file: only C definitions, no initialisers !
* called by: cogen_decls
***************************************************************************** */
int cogen_comp_declare(struct comp_inst *comp)
{
  int warnings     =0;
  int nb_parameters=0;

  //if (verbose) fprintf(stderr, "Writing component   %s=%s() [%i] DECLARE\n",
  //  comp->name, comp->def->name, comp->index);

  if (!comp->def->flag_defined_structure) {
    int index=0;

    coutf("/* component %s=%s() [%i] DECLARE */",
      comp->name, comp->def->name, comp->index);

    comp->def->flag_defined_structure = 1;
    coutf("/* Parameter definition for component type '%s' */",
      comp->def->name);
    cogen_comp_init_defpar(comp); // DEFINITION PARAMETERS can be used in SETTINGS/OUTPUT declaration
    coutf("struct %s_parameters_struct {", comp->def->name);

    /* put there setting, output and declare code */
    for (index=0; index <2; index++) {
      List l = (index == 0 ? comp->def->set_par : comp->def->out_par);

      if(list_len(l) > 0)
      {
        List_handle liter;
        liter = list_iterate(l);
        struct comp_iformal *c_formal;/* Name of component formal input parameter */

        coutf("  /* Component type '%s' %s parameters */",
          comp->def->name, index == 0 ? "setting" : "private");

        while(c_formal = list_next(liter))
        {
          /* check if the SETTING/PRIVATE parameter name also appears in the
             DECLARE code as a single word */
          char flag_is_in_declare_code=0;
          nb_parameters++;

          if(list_len(comp->def->decl_code->lines) > 0) {
            List_handle liter = list_iterate(comp->def->decl_code->lines);
            char *line;                /* Single code line. */
            char *comment_start= NULL; /* this is the C style comment start */
            char *comment_end  = NULL; /* this is the C style comment end */
            char *comment_toend= NULL; /* this is the C++ style comment start (to end of line) */
            while(line = list_next(liter))
            {
              char *subline = line;
              char *p       = NULL;

              /* search for comments */
              if (comment_start)       /* continuation from a previous line */
                comment_start = line;
              else if (!comment_start) /* start of a new comment ? */
                comment_start = strstr(line, "/*");
              comment_end   = strstr(line, "*/");
              if (comment_end && comment_end+2 < line+strlen(line))
                comment_end += 2;
              comment_toend = strstr(line, "//");

              if (comment_start && comment_end) { /* a full C-style comment on a line (or continuation to end) */
                for (p=comment_start; p<comment_end; p++) *p=' ';
                comment_start = comment_end = NULL; /* reset locations for next comment */
              }
              if (comment_start && !comment_end) { /* the start of a multiline C-style comment (or continuation) */
                for (p=comment_start; p<line+strlen(line)-1; p++) *p=' ';
              }
              if (comment_toend) {
                for (p=comment_toend; p<line+strlen(line)-1; p++) *p=' ';
              }

              while (p=strstr(subline, c_formal->id)) {
                /* the parameter name appears in DECLARE code */
                int char_before=0;
                int char_after =0;
                if (p > line)
                  char_before=*(p-1); /* char before the match */
                if (p+strlen(c_formal->id) <= line+strlen(line))
                  char_after=*(p+strlen(c_formal->id)); /* char after the match */
                /* check if appears as a single word */
                if ( (!char_before || (char_before && strchr(" ,\t*",  char_before))) &&
                     (!char_after  || (char_after  && strchr(" ,\t;[=", char_after ))) )
                  flag_is_in_declare_code++;
                else subline = p+strlen(c_formal->id);
                if (flag_is_in_declare_code) break;
                if (p+strlen(c_formal->id) >= line+strlen(line)) break;
              }
              if (flag_is_in_declare_code) break;
            } /* while line */
            list_iterate_end(liter);
          }
          if (flag_is_in_declare_code) {
            continue; /* already in DECLARE code, no need to add it to the structure */
          }

          /* scalar parameter */
          if (c_formal->type != instr_type_string)
            coutf("  %s %s;", instr_formal_type_names_real[c_formal->type], c_formal->id);
          else  /* array parameter */
            coutf("  %s %s[16384];",
              instr_formal_type_names_real[c_formal->type+1], c_formal->id);
        } /* while c_formal */
        list_iterate_end(liter);
      } /* if(list_len(l) > 0) */
    } /* for List in (setpar outpar) */

    /* Output the user declaration code block. */
    if (list_len(comp->def->decl_code->lines) > 0) {
      List_handle liter;                /* For list iteration. */
      char *line;                       /* Single code line. */
      coutf("  /* Component type '%s' DECLARE code stored as structure members */",
        comp->def->name);
      codeblock_out(comp->def->decl_code);
      /* warning/error if decl_code contains '=' char */
      if(list_len(comp->def->decl_code->lines) > 0) {
        liter = list_iterate(comp->def->decl_code->lines);
        while(line = list_next(liter))
          if (strchr(line, '=')) warnings++;
        list_iterate_end(liter);
      }
      if (warnings)
        fprintf(stderr,"Warning: Component %s=%s() DECLARE block contains %i assignments (= sign).\n"
                       "         Move them into the INITIALISE section. May fail at compile.\n"
                       "         File: %s\n",
        	comp->name, comp->def->name, warnings, comp->def->decl_code->quoted_filename);
    }
    if (!nb_parameters)
      coutf("  char %s_has_no_parameters;", comp->def->name);
    coutf("}; /* %s_parameters_struct */", comp->def->name);
    cogen_defundef(comp, comp->def->def_par, PAR_UNDEF); // undef after cogen_comp_init_defpar
    cout("");

    coutf("/* Parameters for component type '%s' */",
     comp->def->name);
    coutf("struct class_%s_struct {", comp->def->name);
      /* make struct: set, pos, rot, declare block */
    coutf("  char     _name[256]; /* e.g. %s */", comp->name);
    coutf("  char     _type[256]; /* %s */", comp->def->name);
    coutf("  long     _index; /* e.g. %i index in TRACE list */",
      index);
    cout( "  Coords   _position_absolute;");
    cout( "  Coords   _position_relative; /* wrt PREVIOUS */");
    cout( "  Rotation _rotation_absolute;");
    cout( "  Rotation _rotation_relative; /* wrt PREVIOUS */");
    cout( "  int      _rotation_is_identity;");
    coutf("  struct   %s_parameters_struct _parameters;", comp->def->name);
    cout("};");
  } /* define class type parameter structure when not done yet (only once) */

  /* instantiate one structure per component instance */
  coutf("struct class_%s_struct _%s_static;", comp->def->name, comp->name);
  coutf("struct class_%s_struct *_%s = &_%s_static;",
    comp->def->name, comp->name, comp->name);
  coutf("#pragma acc declare create ( _%s_static )", comp->name);
  coutf("#pragma acc declare create ( _%s )", comp->name);
  cout("");

  return(warnings);
} /* cogen_comp_declare */

/* *****************************************************************************
* cogen_comp_init_par: write the setting/output parameter allocation in [section]
* input:  a component instance structure pointer (not modified)
*         an instrument structure pointer (not modified)
*         a section as "SETTING" or "PRIVATE"/"OUTPUT"
*
* code is generated in function [comp]_[section=init/save/display/finally]
* called by: cogen_comp_section
***************************************************************************** */
static void cogen_comp_init_par(struct comp_inst *comp, struct instr_def *instr,
                                char *section)
{
  List l = !strcmp(section, "SETTING") ?
             comp->def->set_par : comp->def->out_par;

  if(list_len(l) > 0)
  {
    List_handle list_par = list_iterate(l);
    struct comp_iformal *par;

    while((par = list_next(list_par)) != NULL)
    {
      char *val=NULL;

      if (!strcmp(section, "SETTING")) {
        struct Symtab_entry *entry;
        entry = symtab_lookup(comp->setpar, par->id);
        val   = exp_tostring(entry->val); /* replaced by instrument parameter when exsists */
        code_set_source(instr->quoted_source, exp_getlineno(entry->val));
      } else {
        val =  par->isoptional ? exp_tostring(par->default_value) : NULL;
      }



      if (val) {
        if (par->type == instr_type_string) {
          if (strcmp(val, "0") && strcmp(val, "NULL")) { /* when value is not NULL (avoid warning at compile) */
            coutf("  if(%s && strlen(%s))", val, val);
            coutf("    stracpy(_%s->_parameters.%s, %s ? %s : \"\", 16384);",
              comp->name, par->id, val, val);
            coutf("  else ");
          }
          coutf("_%s->_parameters.%s[0]='\\0';",
            comp->name, par->id);
        } else if (par->type == instr_type_vector) {
          coutf("  _%s->_parameters.%s = (double [])%s; // static pointer allocation", comp->name, par->id, val);
        } else
          coutf("  _%s->_parameters.%s = %s;", comp->name, par->id, val);
        str_free(val);
      }
      /* define the symbol right after assignment so that we can use it in further parameters */
      coutf("  #define %s (_%s->_parameters.%s)", par->id, comp->name, par->id);
    }
    list_iterate_end(list_par);
    if(list_len(l) > 0 && !strcmp(section, "SETTING"))
      code_reset_source();
    cout("");
  }
} /* cogen_comp_init_par */

/* *****************************************************************************
* cogen_comp_init_position: write the position/rotation data
* input:  a component instance structure pointer (not modified)
*         previous component pointer or NULL (for relative stuff)
*         the instrument structure
*
* code is generated in function [comp]_init
* called by: cogen_comp_init
***************************************************************************** */
static void cogen_comp_init_position(struct comp_inst *comp, struct comp_inst *last, struct instr_def *instr)
{
  char d2r[] = "DEG2RAD";
  struct comp_inst *relcomp; /* Component relative to. */
  char *x, *y, *z;

  /* compute coordinates. Can use current instance parameters */
  /* Absolute rotation. */
  x = exp_tostring(comp->pos->orientation.x);
  y = exp_tostring(comp->pos->orientation.y);
  z = exp_tostring(comp->pos->orientation.z);
  relcomp = comp->pos->orientation_rel;
  coutf("  /* component %s=%s() AT ROTATED */",
    comp->name, comp->def->name);
  cout("  {");
  coutf("    Coords tc1, tc2;");
  coutf("    Rotation tr1;");

  if(relcomp == NULL)
  {                                /* Absolute orientation. */
    coutf("    rot_set_rotation(_%s->_rotation_absolute,", comp->name);
    code_set_source(instr->quoted_source,
                    exp_getlineno(comp->pos->orientation.x));
    coutf("      (%s)*%s, (%s)*%s, (%s)*%s);", x, d2r, y, d2r, z, d2r);
    code_reset_source();
  }
  else
  {
    coutf("    rot_set_rotation(tr1,");
    code_set_source(instr->quoted_source,
                    exp_getlineno(comp->pos->orientation.x));
    coutf("      (%s)*%s, (%s)*%s, (%s)*%s);", x, d2r, y, d2r, z, d2r);
    code_reset_source();
    coutf("    rot_mul(tr1, _%s->_rotation_absolute, _%s->_rotation_absolute);", relcomp->name, comp->name);
  }
  str_free(z);
  str_free(y);
  str_free(x);

  /* Relative rotation. */
  if(last == NULL)
  {
    /* First component. */
    coutf("    rot_copy(_%s->_rotation_relative, _%s->_rotation_absolute);", comp->name, comp->name);
  }
  else
  {
    coutf("    rot_transpose(_%s->_rotation_absolute, tr1);", last->name);
    coutf("    rot_mul(_%s->_rotation_absolute, tr1, _%s->_rotation_relative);", comp->name, comp->name);
  }
  coutf("    _%s->_rotation_is_identity =  rot_test_identity(_%s->_rotation_relative);", comp->name, comp->name);

  /* Absolute position. */
  x = exp_tostring(comp->pos->place.x);
  y = exp_tostring(comp->pos->place.y);
  z = exp_tostring(comp->pos->place.z);
  relcomp = comp->pos->place_rel;
  if(relcomp == NULL)
  {
    coutf("    _%s->_position_absolute = coords_set(", comp->name);
    code_set_source(instr->quoted_source, exp_getlineno(comp->pos->place.x));
    coutf("      %s, %s, %s);", x, y, z);
    code_reset_source();
  }
  else
  {
    coutf("    tc1 = coords_set(");
    code_set_source(instr->quoted_source, exp_getlineno(comp->pos->place.x));
    coutf("      %s, %s, %s);", x, y, z);
    code_reset_source();
    coutf("    rot_transpose(_%s->_rotation_absolute, tr1);", relcomp->name);
    coutf("    tc2 = rot_apply(tr1, tc1);");
    coutf("    _%s->_position_absolute = coords_add(_%s->_position_absolute, tc2);", comp->name, relcomp->name);
  }

  str_free(z);
  str_free(y);
  str_free(x);

  /* Relative position. */
  if(last == NULL)
    coutf("    tc1 = coords_neg(_%s->_position_absolute);", comp->name);
  else
    coutf("    tc1 = coords_sub(_%s->_position_absolute, _%s->_position_absolute);", last->name, comp->name);
  coutf("    _%s->_position_relative = rot_apply(_%s->_rotation_absolute, tc1);", comp->name, comp->name);
  coutf("  } /* %s=%s() AT ROTATED */", comp->name, comp->def->name);

  coutf("  DEBUG_COMPONENT(\"%s\", _%s->_position_absolute, _%s->_rotation_absolute);", comp->name, comp->name, comp->name);
  coutf("  instrument->_position_absolute[%i] = _%s->_position_absolute;", comp->index, comp->name);
  coutf("  instrument->_position_relative[%i] = _%s->_position_relative;", comp->index, comp->name);

} /* cogen_comp_init_position */

/* *****************************************************************************
* cogen_comp_section_class: write a common /shared section part for component types
*   generates an mc[comp]_definition_[section](*comp) function.
*   when no DEFINITION parameters are used.
*
* input:  a component instance structure pointer
*         section can be INITIALISE SAVE FINALLY DISPLAY TRACE
* output: 0 when all is fine, non-0 when error found
*
* called by: cogen_[section]
***************************************************************************** */
int cogen_comp_section_class(struct comp_inst *comp,
                       struct instr_def *instr, char *section, char *section_lower,
                       struct code_block *code, int *flag_defined_common)
{
  int    warnings=0;

  /* nothing to do when no component code, except for INITIALISE and TRACE with EXTEND*/
  if (!code || list_len(code->lines) <= 0)
    return(0); /* no [section] code to write */

  /* generate SHARED [section] for all components of given type ************* */
  if (list_len(comp->def->def_par) == 0 /* no DEFINITION parameters */
      && !*flag_defined_common && comp->def->counter_instances > 1) {
    /* we may use a common function for each comp type */
    *flag_defined_common = 1; /* set flag so that definition [section] is done once */
    coutf("/* this function is common to all component type %s with %s code (SHARE) */",
      comp->def->name, section);

    coutf("struct class_%s_struct *class_%s_%s(struct class_%s_struct *comp", comp->def->name, comp->def->name, section_lower, comp->def->name);

    if (!strcmp(section, "TRACE")) /* TRACE: need to define particle state */
    {
      coutf("  , particle *" MCCODE_PARTICLE ") {",
        comp->def->name, comp->def->name, section_lower, comp->def->name);

      cout("  ABSORBED=SCATTERED=RESTORE=0;");
      cout("");
    } else cout(") {");

    cogen_defundef(comp, comp->def->set_par, LOCAL_INSTANCE_PAR_REF); // [par] -> comp->parameters.[par]
    cogen_defundef(comp, comp->def->out_par, LOCAL_INSTANCE_PAR_REF);

    // SHARED comp [section] code here
    codeblock_out(code); // component definition code common to all instances, needs defines

    /* undefine aliases */
    cogen_defundef(comp, comp->def->set_par, PAR_UNDEF);
    cogen_defundef(comp, comp->def->out_par, PAR_UNDEF);

    cout("  return(comp);");
    coutf("} /* class_%s_%s */", comp->def->name, section_lower);

    cout("");

  } /* generated SHARED [section] for component given type */
  return(*flag_defined_common);
} /* cogen_comp_section_class */

/* *****************************************************************************
* cogen_comp_section: write a section part for each component instance
*   generates an mc[comp]__[section](*comp) function.
*   when no DEFINITION parameters are used, a SHARED function is used for all
*   instances of the same component type definition.
*
* input:  a component instance structure pointer
*         section can be INITIALISE SAVE FINALLY DISPLAY TRACE
* output: 0 when all is fine, non-0 when error found
*
* called by: cogen_[section]
***************************************************************************** */
int cogen_comp_section(struct comp_inst *comp,
                       struct instr_def *instr, char *section, char *section_lower,
                       struct code_block *code, int *flag_defined_common)
{
  int    warnings=0;
  int    i=0;
  int    flag_define_aliases=1;

  /* nothing to do when no component code, except for INITIALISE and TRACE with EXTEND*/
  if (strcmp(section, "INITIALISE") && strcmp(section, "TRACE")
    && code && list_len(code->lines) <= 0)
    return(0); /* no [section] code to write */
  if (!strcmp(section, "TRACE") && code && list_len(code->lines) <= 0
    && list_len(comp->extend->lines) <= 0)
    return(0); /* no TRACE code and no EXTEND to write */

  coutf("/* component %s=%s() %s */",
    comp->name, comp->def->name, section);

  /* the [section] instance function **************************************** */
  if (!strcmp(section, "TRACE")) {
    cout("#pragma acc routine seq");
    coutf("particle *_%s_%s(particle *" MCCODE_PARTICLE ")",
      comp->name, section_lower);
  } else
    coutf("int _%s_%s(void)",
      comp->name, section_lower);
  cout("{");

  /* determine if we need to define all the state and comp parameters */
  if (list_len(comp->extend->lines) <= 0 && *flag_defined_common && strcmp(section, "INITIALISE"))
    flag_define_aliases=0;
  else
    coutf( "  #define _MYSELF _%s", comp->name);

    /* init parameters. These can then be used in position/rotation syntax */
    /* all these parameters have a #define pointing to the real name space in structure */
    coutf("  SIG_MESSAGE(\"[_%s_%s] component %s=%s() %s [%s:%i]\");",
        comp->name, section_lower, comp->name, comp->def->name, section,
        code && code->quoted_filename ? code->quoted_filename : comp->def->name,
        code && code->linenum > 0 ? code->linenum : 0);

  if (!strcmp(section, "TRACE")) {

    coutf("  DEBUG_COMP(\"%s\");", comp->name);
    /* Debugging (entry into component). */
    coutf("  DEBUG_STATE()");

    /* update component instance counters */
    coutf("  instrument->counter_N[%i]  ++;", comp->index);
    coutf("  instrument->counter_P[%i]  += p;", comp->index);
    coutf("  instrument->counter_P2[%i] += p*p;", comp->index);

  } else if (!strcmp(section, "DISPLAY") && code && list_len(code->lines) > 0) {
    char *quoted_name = str_quote(comp->name);
    coutf("  printf(\"MCDISPLAY: component %%s\\n\", \"%s\");", quoted_name);
    str_free(quoted_name);
  }

  if (flag_define_aliases)
    warnings += cogen_comp_init_defpar(comp); // specific to each instance


 /* define alias to SETTING and OUTPUT parameters */
 if (flag_define_aliases) {
    cogen_defundef(comp, comp->def->set_par, GLOBAL_INSTANCE_PAR_REF);
    cogen_defundef(comp, comp->def->out_par, GLOBAL_INSTANCE_PAR_REF);
  }

  /* init code. Can use component instance parameters */
  /* Users initializations. Embraced as it may contain local C definitions */

  /* if there are definition parameters, we must put the specific code here */
  if (code && list_len(code->lines) > 0) {
    if (list_len(comp->def->def_par) > 0 || comp->def->counter_instances == 1) {
      if (!strcmp(section, "TRACE")) {
        cout("  ABSORBED=SCATTERED=RESTORE=0;");
      }

      /* the component instance code is here */
      codeblock_out(code);

    } else {
      /* else we call the common init function for each comp type */
      if (!strcmp(section, "TRACE")) {
	cout("#pragma acc routine seq");
        coutf("  class_%s_%s(_%s, " MCCODE_PARTICLE");",
          comp->def->name, section_lower, comp->name);
      }
      else
        coutf("  class_%s_%s(_%s);",
          comp->def->name, section_lower, comp->name);
    }
  }

  /* EXTEND code */
  if (!strcmp(section, "TRACE")) {
    /* put there the EXTEND block, with instrument parameters not in conflict with comp */
    if (list_len(comp->extend->lines) > 0) {
      cogen_defundef(comp, instr->formals, INSTRUMENT_PAR_VALUE);
      codeblock_out(comp->extend);
      cogen_defundef(NULL, instr->formals, PAR_UNDEF);
    }
  }

  if (flag_define_aliases) {
    cogen_defundef(comp, comp->def->set_par, PAR_UNDEF);
    cogen_defundef(comp, comp->def->out_par, PAR_UNDEF);
    cogen_defundef(comp, comp->def->def_par, PAR_UNDEF);
    coutf("  #undef _MYSELF");
  }

  if (!strcmp(section, "TRACE")) {
    /* Debugging (exit from component). */
    cout("  DEBUG_STATE();"); /* uses state parameters */
    cout("  return(" MCCODE_PARTICLE ");");
  } else
    cout("  return(0);");

  coutf("} /* _%s_%s */", comp->name, section_lower);
  cout("");
  return(warnings);
} /* cogen_comp_section */


int cogen_comp_setpos(struct comp_inst *comp, struct comp_inst *last, struct instr_def *instr)
{
  int warnings=0;
  coutf("/* component %s=%s() %s */",
    comp->name, comp->def->name, "SETTING, POSITION/ROTATION");

  /* the set+pos/rot instance function **************************************** */
  coutf("int _%s_%s(void)",
      comp->name, "setpos");
  cout("{ /* sets initial component parameters, position and rotation */");

  coutf( "  #define _MYSELF _%s", comp->name);

  /* init parameters. These can then be used in position/rotation syntax */
  /* all these parameters have a #define pointing to the real name space in structure */
  coutf("  SIG_MESSAGE(\"[_%s_%s] component %s=%s() %s [%s:%i]\");",
        comp->name, "setpos", comp->name, comp->def->name, "SETTING",
        comp->def->init_code && comp->def->init_code->quoted_filename ? comp->def->init_code->quoted_filename : comp->def->name,
        comp->def->init_code && comp->def->init_code->linenum > 0 ? comp->def->init_code->linenum : 0);

  coutf("  stracpy(_%s->_name, \"%s\", 16384);", comp->name, comp->name);
  coutf("  stracpy(_%s->_type, \"%s\", 16384);", comp->name, comp->def->name);
  coutf("  _%s->_index=%i;", comp->name, comp->index);

  /* definition parameters */
  warnings += cogen_comp_init_defpar(comp); // specific to each instance

  /* setting parameters of the component */
  cogen_comp_init_par(comp, instr, "SETTING");  // specific to each instance

  /* output parameters of the component (private/declare) */
  cogen_comp_init_par(comp, instr, "PRIVATE");  // specific to each instance

  /* undef aliases */
  cogen_defundef(comp, comp->def->set_par, PAR_UNDEF);
  cogen_defundef(comp, comp->def->out_par, PAR_UNDEF);
  cogen_defundef(comp, comp->def->def_par, PAR_UNDEF);

  /* position/rotation */
  cogen_comp_init_position(comp, last, instr); // specific to each instance


  coutf("  #undef _MYSELF");

  coutf("  instrument->counter_N[%i]  = instrument->counter_P[%i] = instrument->counter_P2[%i] = 0;",
        comp->index, comp->index, comp->index);
  coutf("  instrument->counter_AbsorbProp[%i]= 0;", comp->index);

  cout("  return(0);");

  coutf("} /* _%s_%s */", comp->name, "setpos");
  cout("");

  return(warnings);
} /* cogen_comp_setpos */

int cogen_comp_acc_attach(struct comp_inst *comp, struct instr_def *instr)
{
  coutf("acc_attach( (void**)&mcinstance_%s );", comp->name);
}

/* calls to cogen_comp_section_class per section type (common/shared) */
int cogen_comp_init_class(struct comp_inst *comp, struct instr_def *instr)
{
  return( cogen_comp_section_class(comp, instr, "INITIALISE", "init",
    comp->def->init_code, &(comp->def->flag_defined_init) ));
}

int cogen_comp_save_class(struct comp_inst *comp, struct instr_def *instr)
{
  return(cogen_comp_section_class(comp, instr, "SAVE", "save",
    comp->def->save_code, &(comp->def->flag_defined_save) ));
}

int cogen_comp_finally_class(struct comp_inst *comp, struct instr_def *instr)
{
  return(cogen_comp_section_class(comp, instr, "FINALLY", "finally",
    comp->def->finally_code, &(comp->def->flag_defined_finally)));
}

int cogen_comp_display_class(struct comp_inst *comp, struct instr_def *instr)
{
  return(cogen_comp_section_class(comp, instr, "DISPLAY", "display",
    comp->def->display_code, &(comp->def->flag_defined_display)));
}

int cogen_comp_trace_class(struct comp_inst *comp, struct instr_def *instr)
{
  return(cogen_comp_section_class(comp, instr, "TRACE", "trace",
    comp->def->trace_code, &(comp->def->flag_defined_trace)));
}

/* calls to cogen_comp_section per section type (instances) */
int cogen_comp_init(struct comp_inst *comp, struct instr_def *instr)
{
  return( cogen_comp_section(comp, instr, "INITIALISE", "init",
    comp->def->init_code, &(comp->def->flag_defined_init) ));
}

int cogen_comp_save(struct comp_inst *comp, struct instr_def *instr)
{
  return(cogen_comp_section(comp, instr, "SAVE", "save",
    comp->def->save_code, &(comp->def->flag_defined_save) ));
}

int cogen_comp_finally(struct comp_inst *comp, struct instr_def *instr)
{
  return(cogen_comp_section(comp, instr, "FINALLY", "finally",
    comp->def->finally_code, &(comp->def->flag_defined_finally)));
}

int cogen_comp_display(struct comp_inst *comp, struct instr_def *instr)
{
  return(cogen_comp_section(comp, instr, "DISPLAY", "display",
    comp->def->display_code, &(comp->def->flag_defined_display)));
}

int cogen_comp_trace(struct comp_inst *comp, struct instr_def *instr)
{
  return(cogen_comp_section(comp, instr, "TRACE", "trace",
    comp->def->trace_code, &(comp->def->flag_defined_trace)));
}

/*******************************************************************************
* cogen_decls: write the declaration part from the instrument description
*   that is the particle definition, the instrument parameters, the DECLARE part,
*   and all SHARE sections from components.
* input:  an instrument definition structure
* output: number of warnings/errors to fix.
*
* code is generated at root level of C file: only C definitions, no initialisers !
* calls: cogen_comp_declare
*******************************************************************************/
int cogen_decls(struct instr_def *instr)
{
  List_handle liter;            /* For list iteration. */
  struct comp_inst *comp;       /* Component instance. */
  struct instr_formal *i_formal;/* Name of instrument formal parameter. */
  long index   =0;
  int  warnings=0;

  /* a previous call to cogen_header writes the file header */

  if (verbose) fprintf(stderr, "Writing instrument '%s' and components DECLARE\n", instr->name);

  cout("");
  cout("/* *****************************************************************************");
  coutf("* instrument '%s' and components DECLARE", instr->name);
  cout("***************************************************************************** */");
  cout("");

  /* 1. particle definition */
  /* moved to cogen_header, as this is needed in mccode-r */

  /* 2. Global variables for instrument parameters. */
  cout("/* Instrument parameters: structure and a table for the initialisation");
  cout("   (Used in e.g. inputparse and I/O function (e.g. detector_out) */");
  cout("");

  int numipar=0;
  cout("struct instrument_parameters_struct {");

  if (!list_len(instr->formals)) {
    coutf("  char %s_has_no_parameter;", instr->name);
  } else {

    liter = list_iterate(instr->formals);


    while(i_formal = list_next(liter))
    {
      if (i_formal->id && strlen(i_formal->id)) {
        coutf("  %s _%s;", instr_formal_type_names_real[i_formal->type], i_formal->id);
        numipar++;
      }
    }
    list_iterate_end(liter);
  }
  cout("};");
  cout("");

  /* check if we have GROUP, SPLIT and JUMP */
  index = list_len(instr->grouplist); // count GROUP
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL) {
    index += list_len(comp->jump);    // count JUMP
    if (comp->split) index++;         // count SPLIT
  }
  list_iterate_end(liter);

  /* 2a. output an instrument logic structure to hold control statement logic */
  if (index > 0) {
    cout("/* instrument SPLIT, GROUP and JUMP control logic */");
    cout("struct instrument_logic_struct {");

    if (list_len(instr->grouplist)) {
      struct group_inst *group;
      liter = list_iterate(instr->grouplist);
      while(group = list_next(liter))
        coutf("  long Group_%s; /* equals index of scattering comp when in group */", group->name);
      list_iterate_end(liter);
    }
    liter = list_iterate(instr->complist);
    while((comp = list_next(liter)) != NULL) {
      if (list_len(comp->jump) > 0) { // JUMP ITERATE counters
        struct jump_struct *this_jump;
        List_handle liter2;
        liter2 = list_iterate(comp->jump);
        while(this_jump = list_next(liter2)) {
          /* create counter for JUMP iteration */
          if (this_jump->iterate)
            coutf("  long Jump_%s_%s; /* the JUMP connection <from>_<to> */", comp->name, this_jump->target);
        }
        list_iterate_end(liter2);
      }
      if (comp->split) {
        coutf("  long Split_%s; /* this is the SPLIT counter decremented down to 0 */", comp->name);
        coutf("  particle Split_%s_particle; /* this is the particle to duplicate */", comp->name);
      }
    }
    cout("};");
    list_iterate_end(liter);
    cout("");
  }

  /* 2b. instrument structure */
  cout("struct instrument_struct {");
  coutf("  char   _name[256]; /* the name of this instrument e.g. '%s' */", instr->name);
  cout( "/* Counters per component instance */");
  coutf("  double counter_AbsorbProp[%i]; /* absorbed events in PROP routines */", list_len(instr->complist)+2);
  coutf("  double counter_N[%i], counter_P[%i], counter_P2[%i]; /* event counters after each component instance */",
    list_len(instr->complist)+2, list_len(instr->complist)+2, list_len(instr->complist)+2);
  coutf("  particle _trajectory[%i]; /* current trajectory for STORE/RESTORE */", list_len(instr->complist)+2);
  cout( "/* Components position table (absolute and relative coords) */");
  coutf("  Coords _position_relative[%i]; /* positions of all components */",
    list_len(instr->complist)+2);
  coutf("  Coords _position_absolute[%i];",
    list_len(instr->complist)+2);
  cout( "  struct instrument_parameters_struct _parameters; /* instrument parameters */");
  if (index)
    cout( "  struct instrument_logic_struct logic; /* instrument logic */");
  cout( "} instrument_static;");
  cout("struct instrument_struct *instrument = & instrument_static;");
  cout("#pragma acc declare create ( instrument_static )");
  cout("#pragma acc declare create ( instrument )");
  cout("");

  /* 4. Table of instrument parameters. Used in mcparseoptions and various output functions */
  coutf("int numipar = %d;", numipar);
  coutf("struct mcinputtable_struct mcinputtable[] = {");
  liter = list_iterate(instr->formals);
  while(i_formal = list_next(liter))
  {
    if (strlen(i_formal->id)) {
      if (i_formal->isoptional  // needed to avoid double quotes in strings
          && !strcmp(instr_formal_type_names[i_formal->type],"instr_type_string"))
        coutf("  \"%s\", &(instrument_static._parameters._%s), %s, %s, ", i_formal->id,
            i_formal->id, instr_formal_type_names[i_formal->type],
            exp_tostring(i_formal->default_value));
      else
        coutf("  \"%s\", &(instrument_static._parameters._%s), %s, \"%s\", ", i_formal->id,
            i_formal->id, instr_formal_type_names[i_formal->type],
            i_formal->isoptional ? exp_tostring(i_formal->default_value) : "");
    }
  }
  list_iterate_end(liter);
  coutf("  NULL, NULL, instr_type_double, \"\"");
  coutf("};");
  cout("");

  /* 5. Component SHAREs. */
  liter = list_iterate(instr->complist);
  index=0;
  while(comp = list_next(liter))
  {
    if((list_len(comp->def->share_code->lines) > 0) && (!comp->def->flag_defined_share))
    {
      if (!index) {
        cout("");
        cout("/* ************************************************************************** */");
        cout("/*             SHARE user declarations for all components                     */");
        cout("/* ************************************************************************** */");
        cout("");
      }
      coutf("/* Shared user declarations for all components types '%s'. */", comp->def->name);
      codeblock_out(comp->def->share_code);
      comp->def->flag_defined_share = 1; /* flag the component so that SHARE outputs only once */
      cout("");
      index++;
    }
  }
  list_iterate_end(liter);
  if (index) {
    cout("");
    cout("/* ************************************************************************** */");
    cout("/*             End of SHARE user declarations for all components              */");
    cout("/* ************************************************************************** */");
    cout("");
  }

  /* 6. write component declares */
  cout("");
  cout("/* ********************** component definition declarations. **************** */");
  cout("");
  liter = list_iterate(instr->complist);
  index=0;
  while(comp = list_next(liter)) {
    comp->index=++index;        /* comp index starts at 1, as in instrument.y */
    comp->def->counter_instances++;
    warnings  += cogen_comp_declare(comp);
  }
  list_iterate_end(liter);
  coutf("int mcNUMCOMP = %d;", list_len(instr->complist));

  /* 7. User's declarations from the instrument definition file. */
  cout("/* User declarations from instrument definition. Can define functions. */");
  codeblock_out(instr->decls);
  cout("");

  /* undefines */
  coutf("#undef compcurname");
  coutf("#undef compcurtype");
  coutf("#undef compcurindex");

  coutf("/* end of instrument '%s' and components DECLARE */", instr->name);
  cout("");

  return(warnings);

} /* cogen_decls */

/* *****************************************************************************
* cogen_section: write a section part from the instrument description
*   and calls all component definition sections
* input:  an instrument definition structure
*         a section as "INITIALISE", "SAVE", "FINALLY", "DISPLAY"
*
* generates the mc[section] function, called by mccode_main
***************************************************************************** */
int cogen_section(struct instr_def *instr, char *section, char *section_lower, struct code_block *code)
{
  int         warnings =0;
  List_handle liter;
  struct comp_inst *comp=NULL, *last=NULL;

  /* instrument section comment */
  if (verbose) fprintf(stderr, "Writing instrument '%s' and components %s\n",
    instr->name, section);

  cout("/* *****************************************************************************");
  coutf("* instrument '%s' and components %s", instr->name, section);
  cout("***************************************************************************** */");
  cout("");

  /* call components to write their code section */
  cout( "#define _MYSELF comp");
  if (!strcmp(section, "DISPLAY")) {
    /* User DECLARE code from component definitions (for each instance). */
    cout("  #define magnify     mcdis_magnify");
    cout("  #define line        mcdis_line");
    cout("  #define dashed_line mcdis_dashed_line");
    cout("  #define multiline   mcdis_multiline");
    cout("  #define rectangle   mcdis_rectangle");
    cout("  #define box         mcdis_box");
    cout("  #define circle      mcdis_circle");
    cout("  #define cylinder    mcdis_cylinder");
    cout("  #define sphere      mcdis_sphere");
  }

  /* first the common definition code if any (when no definition parameter exist) */
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL)
  {
    if (!strcmp(section, "INITIALISE"))
      warnings += cogen_comp_init_class(comp, instr);
    else if (!strcmp(section, "SAVE"))
      warnings += cogen_comp_save_class(comp, instr);
    else if (!strcmp(section, "FINALLY"))
      warnings += cogen_comp_finally_class(comp, instr);
    else if (!strcmp(section, "DISPLAY"))
      warnings += cogen_comp_display_class(comp, instr);
  }
  list_iterate_end(liter);
  cout( "#undef _MYSELF");
  cout("");

  /* then the instance code */
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL)
  {
    if (!strcmp(section, "INITIALISE")) {
      warnings += cogen_comp_setpos(comp, last, instr);
      warnings += cogen_comp_init(comp, instr);
      last = comp;
    }
    else if (!strcmp(section, "SAVE"))
      warnings += cogen_comp_save(comp, instr);
    else if (!strcmp(section, "FINALLY"))
      warnings += cogen_comp_finally(comp, instr);
    else if (!strcmp(section, "DISPLAY"))
      warnings += cogen_comp_display(comp, instr);
  }
  list_iterate_end(liter);
  if (!strcmp(section, "DISPLAY")) {
    /* User DECLARE code from component definitions (for each instance). */
    cout("  #undef magnify");
    cout("  #undef line");
    cout("  #undef dashed_line");
    cout("  #undef multiline");
    cout("  #undef rectangle");
    cout("  #undef box");
    cout("  #undef circle");
    cout("  #undef cylinder");
    cout("  #undef sphere");
  }
  cout("");

  /* then write the instrument main code, which calls component ones */
  cout("#define _MYSELF instrument");
  coutf("int %s(%s) { /* called by mccode_main for %s:%s */",
    section_lower,
    !strcmp(section, "SAVE") ? "FILE *handle" : "void",
    instr->name, section);

  if (!strcmp(section, "INITIALISE"))
  {
    cout("  DEBUG_INSTR();");
    cout("");
    /* default values for instrument parameters are set in mcreadparams */
    cout("  /* code_main/parseoptions/readparams "
      "sets instrument parameters value */");
    coutf("  stracpy(instrument->_name, \"%s\", 256);", instr->name);
  }
  else if (!strcmp(section, "SAVE"))
    coutf("  if (!handle) siminfo_init(NULL);");
  else if (!strcmp(section, "FINALLY")) {
    coutf("  siminfo_init(NULL);");
    coutf("  save(siminfo_file); /* save data when simulation ends */");
  }
  else if (!strcmp(section, "DISPLAY"))
    cout("  printf(\"MCDISPLAY: start\\n\");");
  cout("");

  /* User code from instrument definition. */
  if (code && list_len(code->lines) > 0) {
    coutf("  /* Instrument '%s' %s */", instr->name, section);
    coutf("  SIG_MESSAGE(\"[%s] %s [%s:%i]\");",
      instr->name, section, code->quoted_filename, code->linenum);
    /* defines for the instrument parameters */
    cogen_defundef(NULL, instr->formals, INSTRUMENT_PAR_VALUE);
    codeblock_out_brace(code);
    /* un-defines for the instrument parameters */
    cogen_defundef(NULL, instr->formals, PAR_UNDEF);
  }

  /* must set+pos/rot before comp and instr INIT code */
  if (!strcmp(section, "INITIALISE")) {
    liter = list_iterate(instr->complist);
    while((comp = list_next(liter)) != NULL)
    {
      coutf("  _%s_%s(); /* type %s */",
          comp->name, "setpos", comp->def->name);
    }
    list_iterate_end(liter);
    cout("");
  }

  /* component calls: one call for each component instance */
  coutf("  /* call iteratively all components %s */", section);
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL)
  {
    /* get the component code: no call to it when no code exists (except INIT) */
    struct code_block *comp_code=NULL;

    if (!strcmp(section, "INITIALISE"))
      comp_code = comp->def->init_code;
    else if (!strcmp(section, "SAVE"))
      comp_code = comp->def->save_code;
    else if (!strcmp(section, "FINALLY"))
      comp_code = comp->def->finally_code;
    else if (!strcmp(section, "DISPLAY"))
      comp_code = comp->def->display_code;
    if (!strcmp(section, "INITIALISE") || list_len(comp_code->lines) > 0) {
      /* each component code is executed once, iteratively */
      /* a return code can be set, but does not prevent other components to execute */
      coutf("  _%s_%s(); /* type %s */",
        comp->name, section_lower, comp->def->name);
    }
  }
  list_iterate_end(liter);

  if (!strcmp(section, "INITIALISE")) {
    /* Output graphics representation of components. */
    coutf("  if (mcdotrace) display();");
    cout("  DEBUG_INSTR_END();");
  }
  else if (!strcmp(section, "SAVE"))
    coutf("  if (!handle) siminfo_close(); ");
  else if (!strcmp(section, "FINALLY"))
    coutf("  siminfo_close(); ");
  else if (!strcmp(section, "DISPLAY"))
    cout("  printf(\"MCDISPLAY: end\\n\");");
  cout("");
  cout("  return(0);");
  coutf("} /* %s */", section_lower);
  cout( "#undef _MYSELF");
  cout("");

  return(warnings);
} /* cogen_section */

/* *****************************************************************************
* cogen_init: write the INIT part from the instrument description
*   and calls all component definition sections
* input:  an instrument definition structure
*
* generates the init function, called by mccode_main
*   after mcparseoptions, calling itself mcreadparams
***************************************************************************** */
int cogen_init(struct instr_def *instr)
{
  return(cogen_section(instr, "INITIALISE", "init", instr->inits));
} /* cogen_init */

/* *****************************************************************************
* cogen_save: write the SAVE part from the instrument description
*   and calls all component definition sections
* input:  an instrument definition structure
*
* generates the save function, called by mccode_main
***************************************************************************** */
int cogen_save(struct instr_def *instr)
{
  return(cogen_section(instr, "SAVE", "save", instr->saves));
} /* cogen_save */

/* *****************************************************************************
* cogen_finally: write the SAVE part from the instrument description
*   and calls all component definition sections
* input:  an instrument definition structure
*
* generates the mcfinally function, called by mccode_main
***************************************************************************** */
int cogen_finally(struct instr_def *instr)
{
  return(cogen_section(instr, "FINALLY", "finally", instr->finals));
} /* cogen_finally */

/* *****************************************************************************
* cogen_display: write the DISPLAY part from the instrument description
*   and calls all component definition sections
* input:  an instrument definition structure
*
* generates the display function, called by mccode_main
***************************************************************************** */
int cogen_display(struct instr_def *instr)
{
  return(cogen_section(instr, "DISPLAY", "display", NULL));
} /* cogen_display */

/* *****************************************************************************
* cogen_acc_attach: write acc_attach pragmas for any compnent
***************************************************************************** */
int cogen_acc_attach(struct instr_def *instr)
{
  int         warnings =0;
  List_handle
  liter = list_iterate(instr->complist);
  struct comp_inst *comp;       /* Component instance. */
  cout("#include <openacc.h>");
  while((comp = list_next(liter)) != NULL)
    {
      warnings += cogen_comp_acc_attach(comp, instr);
    }
  cout("acc_attach( (void**)&instrument );");
  return(warnings);
} /* cogen_acc_attach */


/*******************************************************************************
* cogen_trace: Generate the TRACE section.
* Extended Grammar:
*   WHEN: the trace section of comp is embraced in a: if (when) { ...  }
*   GROUP: defines a global Group_<name> flag which gets true when one of the
*          comps SCATTER. Rest of GROUP is then skipped.
*          ABSORB @MCCODE_PARTICLE@ are sent to label absorbComp at the end of component
*          and next comp in GROUP is tested.
*   JUMP:  sends @MCCODE_PARTICLE@ to the JumpTrace labels, either with condition
*          or condition is (counter < iterations)
*   SPLIT: loops from comp/group TRACE to END, incrementing mcrun_num
*******************************************************************************/
int cogen_trace(struct instr_def *instr)
{
   /* TODO:
     ARRAY: handled in grammar: AT/ROTATED copy instance at different locations, use {} or [] vectors
   */

  List_handle       liter;
  struct comp_inst *comp=NULL;
  int               warnings=0;
  int               i=0;
  int               split_counts=0;
  static char *statepars_all[] =
    { /* particle state parameter names are used for defines */
    #if MCCODE_PROJECT == 1     /* neutron */
    #define NUM_STATE_PARS 11
            "x", "y", "z", "vx", "vy", "vz",
            "t", "sx", "sy", "sz", "p"
    #elif MCCODE_PROJECT == 2   /* xray */
    #define NUM_STATE_PARS 12
            "x", "y", "z", "kx", "ky", "kz",
            "phi", "t", "Ex", "Ey","Ez", "p"
    #endif
    };
  List l;

  /* instrument section comment */
  if (verbose) fprintf(stderr, "Writing components %s\n",
    "TRACE");

  cout("/* *****************************************************************************");
  coutf("* components %s", "TRACE");
  cout("***************************************************************************** */");
  cout("");

  /* count if components classes are used more than once */
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL) {
    if (comp->def->counter_instances > 1) i++; /* 'i' is set when at least one class is used more than once */
  }
  list_iterate_end(liter);

  /* define all common function for component "classes" (SHARE TRACE) if needed */
  if (i > 0) {
    /* define state parameters for all TRACE definition/common/shared functions */
    for(i = 0; i < NUM_STATE_PARS; i++)
      coutf("#define %s (" MCCODE_PARTICLE "->%s)", statepars_all[i], statepars_all[i]);
    /* define SCATTERED, ABSORB and RESTORE macros */
    coutf("#define %s (" MCCODE_PARTICLE "->%s)", "SCATTERED", "_scattered");
    coutf("#define %s (" MCCODE_PARTICLE "->%s)", "RESTORE"  , "_restore");
    coutf("#define RESTORE_NEUTRON(_index, ...) if (_index>=0 && _index<=%i) "
      "memcpy(" MCCODE_PARTICLE ", &"
      "instrument->_trajectory[_index], sizeof(particle));",
      list_len(instr->complist));
    coutf("#define STORE_NEUTRON(_index, ...) if (_index>=0 && _index<=%i) "
      "memcpy(&instrument->_trajectory[_index], "
      MCCODE_PARTICLE ", sizeof(particle));",
      list_len(instr->complist));
    coutf("#define %s (" MCCODE_PARTICLE "->%s)", "ABSORBED" , "_absorbed");
    #if MCCODE_PROJECT == 1     /* neutron */
    cout( "#define ABSORB0 do { DEBUG_STATE(); DEBUG_ABSORB(); MAGNET_OFF; ABSORBED++; return(comp); } while(0)");
    #elif MCCODE_PROJECT == 2   /* xray */
    cout( "#define ABSORB0 do { DEBUG_STATE(); DEBUG_ABSORB(); ABSORBED++; return(comp); } while(0)");
    #endif
    cout( "#define ABSORB ABSORB0");
    cout( "#define _MYSELF comp");

    liter = list_iterate(instr->complist);
    while((comp = list_next(liter)) != NULL)
      if (comp->def->counter_instances > 1)
        warnings += cogen_comp_trace_class(comp,instr);
    list_iterate_end(liter);

    for(i = 0; i < NUM_STATE_PARS; i++)
      coutf("#undef %s", statepars_all[i]);
    /* undefine SCATTERED, ABSORBED and RESTORE macros */
    cout("#undef SCATTERED");
    cout("#undef RESTORE"  );
    cout("#undef RESTORE_NEUTRON"  );
    cout("#undef STORE_NEUTRON"  );
    cout("#undef ABSORBED" );
    cout("#undef ABSORB");
    cout("#undef ABSORB0");
    cout("#undef _MYSELF");
    cout("");
  } /* end trace for classes */

  /* call components to write their code section */
  /* define state parameters */
  for(i = 0; i < NUM_STATE_PARS; i++)
    coutf("#define %s (" MCCODE_PARTICLE "->%s)", statepars_all[i], statepars_all[i]);

  /* define SCATTERED, ABSORBED and RESTORE macros */
  coutf("#define %s (" MCCODE_PARTICLE "->%s)", "SCATTERED", "_scattered");
  coutf("#define %s (" MCCODE_PARTICLE "->%s)", "RESTORE"  , "_restore");
  coutf("#define RESTORE_NEUTRON(_index, ...) if (_index>=0 && _index<=%i) "
      "memcpy(" MCCODE_PARTICLE ", &"
      "instrument->_trajectory[_index], sizeof(particle));",
      list_len(instr->complist));
    coutf("#define STORE_NEUTRON(_index, ...) if (_index>=0 && _index<=%i) "
      "memcpy(&instrument->_trajectory[_index], "
      MCCODE_PARTICLE ", sizeof(particle));",
      list_len(instr->complist));
  coutf("#define %s (" MCCODE_PARTICLE "->%s)", "ABSORBED" , "_absorbed");
  #if MCCODE_PROJECT == 1     /* neutron */
  cout( "#define ABSORB0 do { DEBUG_STATE(); DEBUG_ABSORB(); MAGNET_OFF; ABSORBED++; return(" MCCODE_PARTICLE ");} while(0)");
  #elif MCCODE_PROJECT == 2   /* xray */
  cout( "#define ABSORB0 do { DEBUG_STATE(); DEBUG_ABSORB(); ABSORBED++; return(" MCCODE_PARTICLE ");} while(0)");
  #endif
  cout( "#define ABSORB ABSORB0");
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL)
    warnings += cogen_comp_trace(comp, instr);
  list_iterate_end(liter);
  cout("");
  cout("#undef ABSORB");
  cout("#undef ABSORB0");
  /* instrument section comment */
  if (verbose) fprintf(stderr, "Writing instrument '%s' %s\n",
    instr->name, "TRACE");

  cout("/* *****************************************************************************");
  coutf("* instrument '%s' %s", instr->name, "TRACE");
  cout("***************************************************************************** */");
  cout("");

  /* Experimental support for OpenACC CPU parallelisation */
  cout("#pragma acc routine seq");
  /* then write the main code, which calls component ones */
  coutf("int raytrace(particle " MCCODE_PARTICLE "_particle) { /* called by mccode_main for %s:%s */", instr->name, "TRACE");
  cout("  particle *" MCCODE_PARTICLE " = &" MCCODE_PARTICLE "_particle;");
  cout("");
  cout("  /* init variables and counters for TRACE */");

  cout("  #define ABSORB0 do { DEBUG_STATE(); DEBUG_ABSORB(); MAGNET_OFF; ABSORBED++; return(ABSORBED);} while(0)");
  cout("  #define ABSORB ABSORB0");

  /* Debugging (initial state). */
  cout("  DEBUG_ENTER();");
  cout("  DEBUG_STATE();");

  /* intialize split counters */
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL) {
    if (list_len(comp->jump) > 0) { // JUMP ITERATE counters
      struct jump_struct *this_jump;
      List_handle liter2;
      liter2 = list_iterate(comp->jump);
      while(this_jump = list_next(liter2)) {
        /* create counter for JUMP iteration */
        if (this_jump->iterate)
          coutf("  instrument->logic.Jump_%s_%s=0;", comp->name, this_jump->target);
        /* check that the target_index is defined, else search for the target comp index */
        if (!this_jump->target_index) {
          List_handle liter3 = list_iterate(instr->complist);
          struct comp_inst *target=NULL;
          while((target = list_next(liter3)) != NULL) {
            if (!strcmp(target->name, this_jump->target))
              this_jump->target_index = target->index;
          }
          list_iterate_end(liter3);
        }
        if (!this_jump->target_index) /* JUMP e.g. PREVIOUS/NEXT is relative -> absolute */
          this_jump->target_index += comp->index;
      }
      list_iterate_end(liter2);
    }
  }

  cout("");
  cout("  /* the main iteration loop for one incoming neutron */");
  cout("  while (!ABSORBED) { /* iterate neutron event until absorbed */");

  cout("    /* send neutron event to component instance, one after the other */");
  cout("    char flag_nocoordschange=0;");

  /* now we produce the list of statements for each component index, with the attached logic */
  liter = list_iterate(instr->complist);
  while((comp = list_next(liter)) != NULL) {
    List_handle liter2;
    struct comp_inst *comp2=NULL;

    /* the SPLIT loop must be set before we enter further component blocks */
    if (comp->split) {
      char *exp=exp_tostring(comp->split);

      coutf("    /* start SPLIT at %s */", comp->name);

      coutf("    instrument->logic.Split_%s_particle=" MCCODE_PARTICLE "_particle;", comp->name); // store incoming particle state at SPLIT
      coutf("    if (!ABSORBED && " MCCODE_PARTICLE "->_index == %i) ", comp->index);
      coutf("    for (" "instrument->logic.Split_%s = 0; "
                          "instrument->logic.Split_%s< %s; "
                          "instrument->logic.Split_%s++) {",
        comp->name, comp->name, exp, comp->name);
      str_free(exp);
      cout( "    {");
    } // for split
    else
      coutf("    if (!ABSORBED && " MCCODE_PARTICLE "->_index == %i) {", comp->index);

    coutf("      /* component %s=%s() [%i] */", comp->name, comp->def->name, comp->index);
    if (comp->split) {
      char *exp=exp_tostring(comp->split);
      coutf("      " MCCODE_PARTICLE "_particle="
        "instrument->logic.Split_%s_particle;", comp->name); // restore particle for SPLIT loop
      coutf("      p /= %s > 0 ? %s : 1;", exp, exp);
    }

    if (comp->split || comp->when || list_len(comp->jump) > 0) {
      coutf("      #define _MYSELF _%s", comp->name);
      warnings += cogen_comp_init_defpar(comp); // specific to each instance
      cogen_defundef(comp, comp->def->set_par, GLOBAL_INSTANCE_PAR_REF);
      cogen_defundef(comp, comp->def->out_par, GLOBAL_INSTANCE_PAR_REF);
    }
    // coordinate transformations (wrt to PREVIOUS)

    cout( "      if (!flag_nocoordschange) { // flag activated by JUMP to pass coords change");

    coutf("        if (_%s->_rotation_is_identity) {", comp->name);
    coutf("          coords_get("
      "coords_add(coords_set(x,y,z), _%s->_position_relative),"
      "&x, &y, &z);", comp->name);
    cout( "        } else");
    coutf("          mccoordschange(_%s->_position_relative, _%s->_rotation_relative, " MCCODE_PARTICLE ");", comp->name, comp->name);
    cout( "      } else flag_nocoordschange=0;");

    /* call the component when there are TRACE and/or EXTEND lines */
    coutf("      STORE_NEUTRON(%i);", comp->index);
    if (list_len(comp->def->trace_code->lines) > 0 || list_len(comp->extend->lines) > 0) {
      if (comp->when) { // WHEN
        char *exp=exp_tostring(comp->when);
        coutf("      if (%s) // conditional WHEN execution", exp);
        str_free(exp);
      }
      /* call the component instance TRACE function */
      coutf("      _%s_trace(" MCCODE_PARTICLE ");%s", comp->name, list_len(comp->extend->lines) ? " /* contains EXTEND code */" : "");
      cout( "      if (RESTORE) ");
      coutf( "        RESTORE_NEUTRON(%i);", comp->index);
    };

    if (comp->split || comp->when || list_len(comp->jump) > 0) {
      cogen_defundef(comp, comp->def->def_par, PAR_UNDEF);
      cogen_defundef(comp, comp->def->set_par, PAR_UNDEF);
      cogen_defundef(comp, comp->def->out_par, PAR_UNDEF);
      cout("      #undef _MYSELF");
    }
    /* if we have a JUMP, change the index */
    // JUMP
    if(list_len(comp->jump) > 0) {
      struct jump_struct *this_jump;
      List_handle literJ = list_iterate(comp->jump);
      while(this_jump = list_next(literJ)) {
        char *exp = exp_tostring(this_jump->condition);
        /* as there will be a neutron->index++, we subtract 1 to the target */
        if (this_jump->iterate) {
          coutf("      if (++instrument->logic.Jump_%s_%s < %s) { /* test for iteration */",
            comp->name, this_jump->target, exp);
          coutf("        " MCCODE_PARTICLE "->_index = %i;", this_jump->target_index-1);
          cout( "        flag_nocoordschange=1; // pass corrdinate transformations when jumping");
          coutf("      } else " "instrument->logic.Jump_%s_%s=0; /* reset Jump loop and go forward */",
            comp->name, this_jump->target);
        } else {
          coutf("      if (%s) {/* conditional JUMP to %s */", exp, this_jump->target);
          coutf("        " MCCODE_PARTICLE "->_index=%i;", this_jump->target_index-1);
          cout( "        flag_nocoordschange=1; // pass corrdinate transformations when jumping");
          cout( "      }");
        }
      }
      list_iterate_end(literJ);
    }
    /* if we are in a group:
       if (SCATTERED) index = last comp in group
       if (!SCATTERED && index == last_comp in group) ABSORB; */
    // GROUP
    if (comp->group) {
      coutf("      // GROUP %s: from %s [%i] to %s [%i]", comp->group->name,
        comp->group->first_comp, comp->group->first_comp_index,
        comp->group->last_comp,  comp->group->last_comp_index);
      // skip_following_when_scattered (to end of group)
      coutf("      if (SCATTERED) " MCCODE_PARTICLE "->_index = %i; // when SCATTERED in GROUP: reach exit of GROUP after %s",
        comp->group->last_comp_index, comp->group->last_comp);
      // final_absorb_when_all_not_scattered
      if (comp->index == comp->group->last_comp_index)
        coutf("      else ABSORB;     // not SCATTERED at end of GROUP: removes left events", comp->group->last_comp);
      else // comp_absorb_sends_to_next
        coutf("      else ABSORBED=0; // not SCATTERED within GROUP: always tries next");
    }

    coutf("      " MCCODE_PARTICLE "->_index++;");
    coutf("    } /* end component %s [%i] */", comp->name, comp->index);

  } /* end while comp list (case) */
  list_iterate_end(liter);

  /* handle ABSORB when no more comp, go to next comp, and RESTORE */



  /* now we close the SPLIT loops, unrolled from last to 1st */
  liter = list_iterate_back(instr->complist);
  while((comp = list_previous(liter)) != NULL) {
    if (comp && comp->split) {
      coutf( "    } /* end SPLIT at %s */", comp->name);
    }
  }
  list_iterate_end(liter);
  /*   propagate to next component */
  coutf("    if (" MCCODE_PARTICLE "->_index > %d)", list_len(instr->complist));
  /* if we reach the last component, and nothing happened, ABSORB */
  cout( "      ABSORBED++; /* absorbed when passed all components */");

  cout("  } /* while !ABSORBED */");
  cout("");
  cout("  DEBUG_LEAVE()");
  /* Debugging (final state). */
  cout("  DEBUG_STATE()");

  /* undefine state parameters */
  for(i = 0; i < NUM_STATE_PARS; i++)
    coutf("#undef %s", statepars_all[i]);
  /* undefine SCATTERED, ABSORBED and RESTORE macros */
  cout("  #undef SCATTERED");
  cout("  #undef RESTORE");
  cout("  #undef RESTORE_NEUTRON"  );
  cout("  #undef STORE_NEUTRON"  );
  cout("  #undef ABSORBED");
  cout("  #undef ABSORB");
  cout("  #undef ABSORB0");

  cout("");
  cout("  return(" MCCODE_PARTICLE "->_index);");
  coutf("} /* raytrace */");

  return(warnings);

} /* cogen_trace */

/*******************************************************************************
* Output code for the mcstas runtime system. Default is to copy the runtime
* code into the generated executable, to minimize problems with finding the
* right files during compilation and linking, but this may be changed using
* the --no-runtime compiler switch.
*******************************************************************************/
static void
cogen_header(struct instr_def *instr, char *output_name)
{
  char *sysdir_orig;
  char *sysdir_new;
  char  pathsep[3];
  int   i,j=0;
  time_t t;
  char  date[128];
  long  index=0;

  time(&t);
  strcpy(date, ctime(&t));
  if (strlen(date)) date[strlen(date)-1] = '\0';

  /* the file header */
  cout("/* Automatically generated file. Do not edit. ");
  cout(" * Format:     ANSI C source code");
#if MCCODE_PROJECT == 1     /* neutron */
  cout(" * Creator:    McStas <http://www.mcstas.org>");
#elif MCCODE_PROJECT == 2   /* xray */
  cout(" * Creator:    McXtrace <http://www.mcxtrace.org>");
#endif
  coutf(" * Instrument: %s (%s)", instr->source, instr->name);
  coutf(" * Date:       %s", date);
  coutf(" * File:       %s", output_name);
  coutf(" * CFLAGS=%s", instr->dependency);
  cout(" */");
  cout("");
  coutf("#define MCCODE_STRING \"%s\"", MCCODE_STRING);
  coutf("#define FLAVOR        \"%s\"", FLAVOR);
  coutf("#define FLAVOR_UPPER  \"%s\"", FLAVOR_UPPER);
  cout("");
  /* handles Windows '\' chararcters for embedding sys_dir into source code */
  if (MC_PATHSEP_C != '\\') strcpy(pathsep, MC_PATHSEP_S);
  else strcpy(pathsep, "\\\\");

  sysdir_orig = get_sys_dir();
  sysdir_new  = (char *)mem(2*strlen(sysdir_orig));
  for (i=0; i < strlen(sysdir_orig); i++)
  {
    if (sysdir_orig[i] == '\\')
    { sysdir_new[j] = '\\'; j++; sysdir_new[j] = '\\'; }
    else sysdir_new[j] = sysdir_orig[i];
    j++;
  }
  sysdir_new[j] = '\0';
  if(instr->use_default_main)
    cout("#define MC_USE_DEFAULT_MAIN");
  if(instr->enable_trace)
    cout("#define MC_TRACE_ENABLED");
  if(instr->portable)
    cout("#define MC_PORTABLE");

  /* particle definition */
  cout("#if MC_RAND_ALG==5");
  cout("#include <openacc_curand.h>");
  cout("#include <accelmath.h>");
  cout("#define PI 3.14159265358979323846");
  cout("#define M_PI PI");
  cout("#else");
  cout("#include <math.h>");
  cout("#endif");
  cout("struct particle_struct {");
  cout("  double x,y,z; /* position [m] */");
#if MCCODE_PROJECT == 1   /* neutron */
  cout("  double vx,vy,vz; /* velocity [m/s] */");
  cout("  double sx,sy,sz; /* spin [0-1] */");
#elif MCCODE_PROJECT == 2 /* xray */
  cout("  double kx,ky,kz; /* wave-vector */");
  cout("  double phi, Ex,Ey,Ez; /* phase and electrical field */");
#endif
  cout("#if MC_RAND_ALG == 5");
  cout("  curandState_t MCRANDstate; /* CUDA RNG state */");
  cout("#endif");
  cout("  double t, p;    /* time, event weight */");
  cout("  long long _uid;  /* event ID */");
  cout("  long _index;     /* component index where to send this event */");
  /* these are needed for SCATTERED, ABSORB and RESTORE macros */
  cout("  long _absorbed;  /* flag set to TRUE when this event is to be removed/ignored */");
  cout("  long _scattered; /* flag set to TRUE when this event has interacted with the last component instance */");
  cout("  long _restore;   /* set to true if neutron event must be restored */");
  cout("};");
  cout("typedef struct particle_struct particle;");
  cout("");


  if(instr->include_runtime)
  {
    cout("#define MC_EMBEDDED_RUNTIME"); /* Some stuff will be static. */
    embed_file("mccode-r.h");
#if MCCODE_PROJECT == 1     /* neutron */
    embed_file("mcstas-r.h");
#elif MCCODE_PROJECT == 2   /* xray */
    embed_file("mcxtrace-r.h");
#endif
    /* NeXus support, only active with -DUSE_NEXUS */
    if (verbose) fprintf(stderr, "Compile            '%s -DUSE_NEXUS -lNeXus' to enable NeXus support\n", output_name);
    embed_file("mccode-r.c");
#if MCCODE_PROJECT == 1     /* neutron */
    embed_file("mcstas-r.c");
#elif MCCODE_PROJECT == 2   /* xray */
    embed_file("mcxtrace-r.c");
#endif
  }
  else
  {
    coutf("#include \"%s%sshare%smccode-r.h\"",  sysdir_new, pathsep, pathsep);
    fprintf(stderr,"Dependency: %s.o\n", "mccode-r");
#if MCCODE_PROJECT == 1     /* neutron */
    coutf("#include \"%s%sshare%smcstas-r.h\"",  sysdir_new, pathsep, pathsep);
    fprintf(stderr,"Dependency: %s.o\n", "mcstas-r");
#elif MCCODE_PROJECT == 2   /* xray */
    coutf("#include \"%s%sshare%smcxtrace-r.h\"",  sysdir_new, pathsep, pathsep);
    fprintf(stderr,"Dependency: %s.o\n", "mcxtrace-r");
#endif

    fprintf(stderr,"Dependency: %s.o\n", "mcstas-r");
    fprintf(stderr,"Dependency: '-DUSE_NEXUS -lNeXus' to enable NeXus support\n");
    fprintf(stderr,"To build instrument '%s', compile and link with these libraries (in %s%sshare)\n",
      instrument_definition->quoted_source, sysdir_new, pathsep);
  }
  cout("");
  cout("/* *****************************************************************************");
  coutf("* Start of instrument '%s' generated code", instr->name);
  cout("***************************************************************************** */");
  cout("");
  coutf("#ifdef MC_TRACE_ENABLED");
  coutf("int traceenabled = 1;");
  coutf("#else");
  coutf("int traceenabled = 0;");
  coutf("#endif");

  coutf("#define " MCCODE_LIBENV " \"%s%s\"", sysdir_new,pathsep);

  coutf("int   defaultmain         = %d;", instr->use_default_main);
  coutf("char  instrument_name[]   = \"%s\";", instr->name);
  coutf("char  instrument_source[] = \"%s\";", instr->quoted_source);
  coutf("char *instrument_exe      = NULL; /* will be set to argv[0] in main */");

  /* embed instrument file if requested with --source option */
  if (embed_instrument_file) {

    FILE *fid=fopen(instr->source, "rb");
    if (fid) {
      char *content=NULL;
      char *content_quoted=NULL;
      fseek(fid, 0, SEEK_END);
      index = ftell(fid);
      fseek(fid, 0, SEEK_SET);
      content = malloc(index + 1);
      /* read full file content */
      fread(content, index, 1, fid);
      fclose(fid);
      content[index] = '\0';
      content_quoted = str_quote(content);
      coutf("char  instrument_code[]   = \"%s\";\n", content_quoted);
      str_free(content_quoted);
      str_free(content);
    }
  }
  /* if option is not set, or source file can not be accessed */
  if (!index)
    coutf("char  instrument_code[]   = "
    "\"Instrument %s source code %s is not embedded in this executable.\\n"
    "  Use --source option when running " MCCODE_NAME ".\\n\";", instr->name, instr->quoted_source);

  cout("");
  if(instr->use_default_main)
    cout("int main(int argc, char *argv[]){return mccode_main(argc, argv);}");
} /* cogen_header */

/*******************************************************************************
* cogen: the code generator
*   Generate the output file (in C).
*******************************************************************************/
void
cogen(char *output_name, struct instr_def *instr)
{
  fprintf(stdout, "cogen(char *output_name, struct instr_def *instr)\n");


  int warnings=0;

  /* INITIALISE output file. */
  if(!output_name || !output_name[0] || !strcmp(output_name, "-"))
  {
    output_handle = fdopen(1, "w");
    quoted_output_file_name = str_dup("<stdout>");
  }
  else
  {
    output_handle = fopen(output_name, "w");
    quoted_output_file_name = str_quote(output_name);
  }
  num_next_output_line = 1;
  if(output_handle == NULL)
    fatal_error("Error opening output file '%s'\n", output_name);

  /* and we now call the writers */
  cogen_header(instr, output_name);
  warnings += cogen_decls(instr); /* return nb of warnings */
  warnings += cogen_init(instr);
  warnings += cogen_trace(instr);
  warnings += cogen_save(instr);
  warnings += cogen_finally(instr);
  warnings += cogen_display(instr);
  embed_file("mccode_main.c");

  if (verbose && warnings)
    fprintf(stderr,"Warning: The build of the instrument '%s' has %i warnings/errors.\n",
        	instr->name, warnings);
  coutf("/* end of generated C code %s */", output_name);

  fclose(output_handle);
  /* This writes a snippet c-code with calls to acc_attach for OpenACC use */
  output_handle = fopen("mccode_attaches.c", "w");
  warnings += cogen_acc_attach(instr);


} /* cogen */
