/*******************************************************************************
*
* McStas, neutron ray-tracing package
*         Copyright 1997-2002, All rights reserved
*         Risoe National Laboratory, Roskilde, Denmark
*         Institut Laue Langevin, Grenoble, France
*
* Component: Single_MX_crystal
*
* %I
*
* Written by: Erik B Knudsen
* Date: Apr,. 2017
* Version: $Revision$
* Release: McStas 2.4
* Origin: DTU Physics
*
* Single crystal model whcih may be faster when dealing with large scale models
*
* %D
* This single crystal model is intended for use when the model used by Single_crystal gets problems
* because of long reflection lists 
*
* %P
* Input parameters:
* xwidth:  [m] Width of the crystal (box)
* yheight: [m] Height of the crystal (cylindrical or box).
* zdepth:  [m] Depth of the crystal (box).
* radius:  [m] Radius of the crystal (cylinder or sphere).
* reflections: [text] The file containing the reflection list.
* sig_inc: [ ] Incoherent cross-section of the crystal.
* sig_abs: [ ] Absorption cross-section of the crystal. 
* 
* %E
*******************************************************************************/

DEFINE COMPONENT Single_MX_crystal
DEFINITION PARAMETERS ()
SETTING PARAMETERS (string reflections="", xwidth=0, yheight=0.02, zdepth=0, radius=0.01, 
        sig_inc=1, sig_abs=0, p_inc=0.1,p_transmit=0.1 ,ax=0, ay=0, az=0, bx=0, by=0, bz=0, cx=0, cy=0, cz=0,
        delta_d_d=1e-4, mosaic=1e-4, sigma_abs=0, sigma_inc=0
)
OUTPUT PARAMETERS (prms)
/* Neutron parameters: (x,y,z,vx,vy,vz,t,sx,sy,sz,p) */ 

SHARE
%{
    %include "read_table-lib"

    typedef struct sx_MX_t {
            double a_x,a_y,a_z, b_x,b_y,b_z, c_x,c_y,c_z;
            double asx,asy,asz, bsx,bsy,bsz, csx,csy,csz;
            double V0;
            double mosaic;
            double dets;
            double adjs[3][3];
    } sx_MX_t;

    double norm2(int valc, double *vals, int *cols){
        double res=0;
        int j;
        for (j=0; j<valc; j++){
            res+=vals[(cols?cols[j]:j)]*vals[(cols?cols[j]:j)];
        }
        return res;
    }


    /*!
     * \brief Searches a table for multiple values in mulitple columns
     * Returns the index, r, of the first row in the table where:
     * T(data[cols[0],r])==vals[0] && T(data[cols[1],r])==vals[1] && ... && T(data[cols[search_cols],r])==vals[search_cols]
     * First the table is binary searched for limits d\in[d_{min}:d_{max}] where the d-spacing is close (two binary searches). 
     * Then this shortlist is searched linearly for the closest match.
     * \param T The table to be searched.
     * \param search_cols Number of values to match
     * \param cols Array containing the column numbers to look in 
     * \param values Array containing the values to match against the table.
     */

    int Table_Multicol_Find(t_Table T, int search_cols, int *cols, double *values){
        int row=0;
        double valsum=0;
        int i,found=0;
        double left=0,right=0,mid=0, midp1=0;
        int li,mi,ri,limits[2];
        int c=T.columns;

        /* binary search to find the  of the smallest d-spacing strictly larger
         * than the target. */
        valsum=norm2(search_cols, values,NULL);
        /* initialize binary search for upper limit.*/
        li=0; ri=T.rows-1;
        while (li<ri){
            mi=li+(ri-li)/2;
            mid=norm2(search_cols, &(T.data[mi*c+cols[0]]),NULL);
            midp1=norm2(search_cols, &(T.data[(mi+1)*c+cols[0]]),NULL);
            if(mid<=valsum && valsum<(midp1)){
                li=mi;ri=li-1;
            }else if (mid<=valsum){
                li=mi+1;
            }else{
                ri=mi-1;
            }
        }
        limits[0]=li;
        limits[1]=li+1;
        /*Search for the lower limit where th d-spacing is identical to the one found*/
        double target=norm2(search_cols, &(T.data[limits[0]*c+cols[0]]),NULL);
        //printf("lim0 search: %d %g\n",limits[0],norm2(search_cols, &(T.data[(limits[0])*c+cols[0]]),NULL));
        while (limits[0]>0 && norm2(search_cols, &(T.data[(limits[0]-1)*c+cols[0]]),NULL)==target){
            //printf("lim0 search: %d %g\n",limits[0],norm2(search_cols, &(T.data[(limits[0])*c+cols[0]]),NULL));
            limits[0]-=1;
        }
        /*Search for the upper limit (the last of the largest (identical) d-spacings strictly smaller than the one found)*/
        target=norm2(search_cols, &(T.data[limits[1]*c+cols[0]]),NULL);
            //printf("lim1 search: %d %g\n",limits[1],norm2(search_cols, &(T.data[(limits[1])*c+cols[0]]),NULL));
        while (limits[1]<T.rows-1 && norm2(search_cols, &(T.data[(limits[1]+1)*c+cols[0]]),NULL)==target){
            //printf("lim1 search: %d %g\n",limits[1],norm2(search_cols, &(T.data[(limits[1])*c+cols[0]]),NULL));
            limits[1]+=1;

        }

        /*second search to find the last of the largest d-spacing stricly smaller than the target
         * This is done by the same aolgorith as before but using negative values.*/
        /* initialize binary search for upper limit.*/
        //li=0; ri=T.rows-1;
        //double target2=(-mid)+1e-9;
        //double target2=(-norm2(search_cols, &(T.data[limits[1]*c+cols[0]]),NULL))+1e-9;
        //while (li<ri){
        //    mi=li+(ri-li)/2;
        //    mid=-norm2(search_cols, &(T.data[mi*c+cols[0]]),NULL);
        //    midp1=-norm2(search_cols, &(T.data[(mi-1)*c+cols[0]]),NULL);
        //    if(mid<=(target2) && (target2)<(midp1)){
        //        li=mi;ri=li-1;
        //    }else if (mid<=(target2)){
        //        ri=mi-1;
        //    }else{
        //        li=mi+1;
        //    }
        //}
        //limits[0]=li;
/**/
/*        double left_lim=0;*/
/*        double right_lim=0;*/
/*        for (i=0;i<search_cols;i++){*/
/*            left_lim+=pow(floor(fabs(values[i])),2.0);*/
/*            right_lim+=pow(ceil(fabs(values[i])),2.0);*/
/*        }*/
/**/
/*        valsum=norm2(search_cols, values,NULL);*/

        /*do binary searches to find a point where norm(L)<norm(values)<nrom(right)*/

/*        left=norm2(search_cols, &(T.data[li*c+cols[0]]),NULL);*/
/*        middle=norm2(search_cols, &(T.data[mi*c+cols[0]]),NULL);*/
/*        right=norm2(search_cols, &(T.data[ri*c+cols[0]]),NULL);*/
        /*Binary search in table for value sum*/
/*        while(li<=ri && !found){*/
/*            if (valsum>middle){*/
/*                li=mi+1;*/
/*                left=norm2(search_cols, &(T.data[li*c+cols[0]]),NULL);*/
/*            }else{*/
/*                ri=mi-1;*/
/*                left=norm2(search_cols, &(T.data[ri*c+cols[0]]),NULL);*/
/*            }*/
/*            mi=(ri+li)/2;*/
/*            middle=norm2(search_cols, &(T.data[mi*c+cols[0]]),NULL);*/
/*            if (left<valsum && middle>valsum && !right>middle) */
/*        }*/
/*        found = (middle> left_lim) && (middle<right_lim); */
        //printf("found at idx = (%d %d %d) => (%g %g %g) ~= (%g %g %g), N1=%g ~= %g \n",li,mi,ri,left,middle,right, values[0], values[1], values[2], pow(T.data[mi*c+cols[0]],2.0)+pow(T.data[mi*c+cols[1]],2.0)+pow(T.data[mi*c+cols[2]],2.0),valsum);
        //printf("qsearch= (%g %g %g), got: (%g %g %g)...(%g %g %g)\n",values[0],values[1],values[2],T.data[li*c+0],T.data[li*c+1],T.data[li*c+2],T.data[ri*c+0],T.data[ri*c+1],T.data[ri*c+2]);
        //printf("limits: %d %d   %g %g  %g\n",limits[0],limits[1],pow(T.data[limits[0]*c+cols[0]],2.0)+pow(T.data[limits[0]*c+cols[1]],2.0)+pow(T.data[limits[0]*c+cols[2]],2.0),pow(T.data[limits[1]*c+cols[0]],2.0)+pow(T.data[limits[1]*c+cols[1]],2.0)+pow(T.data[limits[1]*c+cols[2]],2.0), valsum); 
        /*So we now have some limits as to where things may be found*/
        /*loop through and check all of them in turn*/
        double d2_small=FLT_MAX;
        int i_small=-1;
        for (i=limits[0];i<limits[1];i++){
            double d2=(T.data[i*c+cols[0]]-values[0])*(T.data[i*c+cols[0]]-values[0]) +  (T.data[i*c+cols[1]]-values[1])*(T.data[i*c+cols[1]]-values[1]) + (T.data[i*c+cols[2]]-values[2])*(T.data[i*c+cols[2]]-values[2]);
            if ( d2<0.5){
                printf("%d FOUND! %g %g %g ~= %g %g %g, d2=%g\n",i,values[0],values[1],values[2], T.data[i*c+cols[0]],T.data[i*c+cols[1]],T.data[i*c+cols[2]], (pow(T.data[i*c+cols[0]]-values[0],2.0)+pow(T.data[i*c+cols[1]]-values[1],2.0)+pow(T.data[i*c+cols[2]]-values[2],2.0)));
                /*early exit*/
                return i;
            }else if (d2<d2_small){
                d2_small=d2;
                i_small=i;
                printf("%d CONFOUND! %g %g %g ~= %g %g %g, d2=%g\n",i,values[0],values[1],values[2], T.data[i*c+cols[0]],T.data[i*c+cols[1]],T.data[i*c+cols[2]], (pow(T.data[i*c+cols[0]]-values[0],2.0)+pow(T.data[i*c+cols[1]]-values[1],2.0)+pow(T.data[i*c+cols[2]]-values[2],2.0)));
            }
        }
        return i_small;
    }

    double quasi_rand01(int axis){
        const int no_primes=64;
        const int primes[]={2,3,5,7,9,11,13,17,19,23,29,
            31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 
            73, 79, 83, 89, 97, 101, 103, 107, 109, 113};

        double f, hn;
        long long n0, n1, r;

        hn = 0.0;
        f = 1.0/primes[axis];
        n0 = mcget_run_num();
        while ( n0>0 ) 
        {
            n1 = n0/primes[axis];
            r = n0-n1*primes[axis];
            hn += f*r;
            f = f/primes[axis];
            n0 = n1;
        }
        return hn;
    }

    int nearest_kf_from_q(sx_MX_t crystal_prms, t_Table T, double qx, double qy,double qz, double *kfx, double *kfy, double *kfz){
        /*assemble the hbar vector (the estimated hkl)*/
        /*find */ 
    }

%}

DECLARE
%{
    struct {
        enum {BOX, CYLINDER, SPHERE} shape;
        t_Table reftable;
        int col_h, col_k, col_l, col_F2, col_d_spc;
        double mosaic, mosaic_a, mosaic_b, mosaic_c;
        sx_MX_t sxp;
    } prms;
    

%}

INITIALIZE
%{
    
    double tmp_x,tmp_y, tmp_z;


    if (yheight && radius) {
        prms.shape=CYLINDER;
    }

    int status;
    if ( (status=Table_Read(&(prms.reftable),reflections,0))==-1){
        fprintf(stderr,"Error (%s): reflection list (%s) not read cleanly. Aborting.\n",NAME_CURRENT_COMP, prms.reftable);
        exit(-1);
    }

    prms.col_h=0;prms.col_k=1;prms.col_l=2;prms.col_F2=3;



    prms.sxp.a_x=ax; prms.sxp.a_y=ay; prms.sxp.a_z=az;
    prms.sxp.b_x=bx; prms.sxp.b_y=by; prms.sxp.b_z=bz;
    prms.sxp.c_x=cx; prms.sxp.c_y=cy; prms.sxp.c_z=cz;
    
    /*from the direct unit cell vectors compute the reciprocal ones*/
    vec_prod(tmp_x, tmp_y, tmp_z,  prms.sxp.b_x, prms.sxp.b_y, prms.sxp.b_z, prms.sxp.c_x, prms.sxp.c_y, prms.sxp.c_z);
    prms.sxp.V0 = fabs(scalar_prod(prms.sxp.a_x, prms.sxp.a_y, prms.sxp.a_z, tmp_x, tmp_y, tmp_z));
    printf("V0=%g\n", prms.sxp.V0);

    prms.sxp.asx = 2*PI/prms.sxp.V0*tmp_x;
    prms.sxp.asy = 2*PI/prms.sxp.V0*tmp_y;
    prms.sxp.asz = 2*PI/prms.sxp.V0*tmp_z;
    vec_prod(tmp_x, tmp_y, tmp_z, prms.sxp.c_x, prms.sxp.c_y, prms.sxp.c_z, prms.sxp.a_x, prms.sxp.a_y, prms.sxp.a_z);
    prms.sxp.bsx = 2*PI/prms.sxp.V0*tmp_x;
    prms.sxp.bsy = 2*PI/prms.sxp.V0*tmp_y;
    prms.sxp.bsz = 2*PI/prms.sxp.V0*tmp_z;
    vec_prod(tmp_x, tmp_y, tmp_z, prms.sxp.a_x, prms.sxp.a_y, prms.sxp.a_z, prms.sxp.b_x, prms.sxp.b_y, prms.sxp.b_z);
    prms.sxp.csx = 2*PI/prms.sxp.V0*tmp_x;
    prms.sxp.csy = 2*PI/prms.sxp.V0*tmp_y;
    prms.sxp.csz = 2*PI/prms.sxp.V0*tmp_z;

    printf("a*=[ %g %g %g ]\n",prms.sxp.asx, prms.sxp.asy, prms.sxp.asz);
    printf("b*=[ %g %g %g ]\n",prms.sxp.bsx, prms.sxp.bsy, prms.sxp.bsz);
    printf("c*=[ %g %g %g ]\n",prms.sxp.csx, prms.sxp.csy, prms.sxp.csz);
    
    /* compute the inverse of the [as bs cs] matrix. This will allow going back and forth from q to hkl*/
    prms.sxp.dets = prms.sxp.asx*(prms.sxp.bsy*prms.sxp.csz - prms.sxp.bsz*prms.sxp.csy) 
        - prms.sxp.bsx*(prms.sxp.asy*prms.sxp.csz-prms.sxp.asz*prms.sxp.csy) 
        + prms.sxp.csz*(prms.sxp.asy*prms.sxp.bsz - prms.sxp.asz*prms.sxp.bsy); 
    
    prms.sxp.adjs[0][0]= (prms.sxp.bsy*prms.sxp.csz - prms.sxp.csy*prms.sxp.bsz)/prms.sxp.dets;
    prms.sxp.adjs[0][1]=-(prms.sxp.bsx*prms.sxp.csz - prms.sxp.csx*prms.sxp.bsz)/prms.sxp.dets;
    prms.sxp.adjs[0][2]= (prms.sxp.bsx*prms.sxp.csy - prms.sxp.csx*prms.sxp.bsy)/prms.sxp.dets;

    prms.sxp.adjs[1][0]=-(prms.sxp.asy*prms.sxp.csz - prms.sxp.csy*prms.sxp.asz)/prms.sxp.dets;
    prms.sxp.adjs[1][1]= (prms.sxp.asx*prms.sxp.csz - prms.sxp.csx*prms.sxp.asz)/prms.sxp.dets;
    prms.sxp.adjs[1][2]=-(prms.sxp.asx*prms.sxp.csy - prms.sxp.csx*prms.sxp.asy)/prms.sxp.dets;

    prms.sxp.adjs[2][0]= (prms.sxp.asy*prms.sxp.bsz - prms.sxp.bsy*prms.sxp.asz)/prms.sxp.dets;
    prms.sxp.adjs[2][1]=-(prms.sxp.asx*prms.sxp.bsz - prms.sxp.bsx*prms.sxp.asz)/prms.sxp.dets;
    prms.sxp.adjs[2][2]= (prms.sxp.asx*prms.sxp.bsy - prms.sxp.bsx*prms.sxp.asy)/prms.sxp.dets;

    printf("det =%g\n",prms.sxp.dets);
    printf("     [%g %g %g]\n",prms.sxp.adjs[0][0],prms.sxp.adjs[0][1],prms.sxp.adjs[0][2]);
    printf("adjs=[%g %g %g]\n",prms.sxp.adjs[1][0],prms.sxp.adjs[1][1],prms.sxp.adjs[1][2]);
    printf("     [%g %g %g]\n",prms.sxp.adjs[2][0],prms.sxp.adjs[2][1],prms.sxp.adjs[2][2]);

    /* Mosaicity calcs.*/

    /* Find two arbitrary axes perpendicular to tau and each other. */
    /*normal_vec(b1[0], b1[1], b1[2],
            list[i].u1x, list[i].u1y, list[i].u1z);
    vec_prod(b2[0], b2[1], b2[2],
            list[i].u1x, list[i].u1y, list[i].u1z,
            b1[0], b1[1], b1[2]);
    */
    /* Use isotropic mosaic. */
    /*  list[i].u2x = b1[0];
    list[i].u2y = b1[1];
    list[i].u2z = b1[2];
    sig2 = FWHM2RMS*list[i].tau*MIN2RAD*SC_mosaic;
    list[i].u3x = b2[0];
    list[i].u3y = b2[1];
    list[i].u3z = b2[2];
    sig3 = FWHM2RMS*list[i].tau*MIN2RAD*SC_mosaic;
    */



%}

TRACE
%{
    double t0,t1,qx,qy,qz,qmax, k,kfx,kfy,kfz;
    const int hcol=0,kcol=1,lcol=2;
    
    /* propagate neutron to crystal hull */
    int status= cylinder_intersect(&t0,&t1, x,y,z,vx,vy,vz, radius, yheight);
    if(status){
        status=0;
        if(t0>0){
            PROP_DT(t0);
        }

        long long nid;
        /* An aproximation of the total coh cross section could be to integrate all incoming directions
         * and thereby get an effective one which should be relevant for incoming directions
         */
        /*For now pick a random scattering point on the trajectory*/
        double dt=t1-t0;
        double vn=sqrt(scalar_prod(vx,vy,vz,vx,vy,vz))/2200.0;
        dt=rand01()*dt;
        /*Check unit of this - clearly this is wrong*/
        p*=exp(-vn*sigma_abs*dt);

        PROP_DT(dt);
        nid=mcget_run_num();
        SCATTER;
        /*pick a random direction in reciprocal space*/
        randvec_target_circle(&qx,&qy, &qz, NULL, 0,0,1, 0);

        /*so qmax needs to come from whatever the maximum q we can reach for this neutron happens to be.*/
        qmax=120;
        double q=sqrt(scalar_prod(vx,vy,vz,vx,vy,vz))*V2K;//  rand01()*pow(qmax,0.33333333333333333333);
        NORM(qx,qy,qz);
        qx*=q; qy*=q; qz*=q;
        /*the search columns  - could rely on default for Table_Multicol_Find*/
        int cols[]={0,1,2};

        double qq[3], g[3], tmp[3];
        qq[0]=-vx*V2K+qx; qq[1]=-vy*V2K+qy; qq[2]=-vz*V2K+qz;
        //qq[0]=-0*vx*V2K+qx; qq[1]=-0*vy*V2K+qy; qq[2]=-0*vz*V2K+qz;
        int ht,kt,lt;
        double hkle=1e-4;
        ht=-9;kt=-3;lt=34;
        ht=0;kt=1;lt=1;
        ht=-4;kt=-4;lt=5;
        ht=7;kt=-1;lt=2;

        //qq[0]=(ht+hkle)*prms.sxp.asx + (kt+hkle)*prms.sxp.bsx+ (lt+hkle)*prms.sxp.csx;
       // qq[1]=(ht+hkle)*prms.sxp.asy + (kt+hkle)*prms.sxp.bsy+ (lt+hkle)*prms.sxp.csy;
       // qq[2]=(ht+hkle)*prms.sxp.asz + (kt+hkle)*prms.sxp.bsz+ (lt+hkle)*prms.sxp.csz;

        /* the vector g is an "hkl"-equivalent to search in the reflection list for nearest neighbour match*/
        g[0]=prms.sxp.adjs[0][0]*qq[0] + prms.sxp.adjs[0][1]*qq[1]+ prms.sxp.adjs[0][2]*qq[2]; 
        g[1]=prms.sxp.adjs[1][0]*qq[0] + prms.sxp.adjs[1][1]*qq[1]+ prms.sxp.adjs[1][2]*qq[2]; 
        g[2]=prms.sxp.adjs[2][0]*qq[0] + prms.sxp.adjs[2][1]*qq[1]+ prms.sxp.adjs[2][2]*qq[2]; 
        
        //g[0]=32.9;g[1]=33.1;g[2]=42.1;

        printf("qentry %g %g %g\n",qq[0],qq[1],qq[2]); 
        printf("gentry %g %g %g\n",g[0],g[1],g[2]);
        /*find the nearest neighbour in terms of g vector*/
        int r=Table_Multicol_Find(prms.reftable, 3, cols, g);





        /*TODO
          1. add possibility of "quasi-tunneling"
          2. for a given direction pick either coherent or incoherent
          3. weight according to the scattering cross-section and p_transmit(if given)
          4. add option of multiple scattering?
          5. "Weight according to scattering on the outward line?"
         */

        /* Do some probability gymnastics on the tunneling options(exit option) which will be the "no more scatering branch"
         * That is 1 - (1-exp(-mu_coh *l_remain)) - (1-exp(-mu_inc*l_remain))
         * 2nd term is possibility of scattering coherently on outward line, 3rd is prob for inc on same line
         * next iteration we may do the same again to catch multiples*/

        /*if coherent do this*/

        /* To get a real q we should replace the sampling above with a sampling on a sphere with radius ki.
         * To get at the Ewald construction we should do the transformation (as in old Single crystal) to center the
         * sphere on the origin of ki (i.e. q=q'-ki, where q' is the sampled q-vector).
         * How would the incoming transformation be to put ki along z of the crystal? (Should be as in old SX, no)
         * Mosaicity could be handled by a simple MC-choice in an ellisoid.
         */

        /* Need to somehow get at the total coherent cross section to be able to weight properly between the two
         * options.
         */


        /* Pick a point in the 3D mosaic gaussian blob.
         * - Either by picking a point by means of three randnorm calls or by
         * uniform sampling within n sigma and adjust weight.
         * - For testing however- we shall just choose the lattice point.*/

        int hh,kk,ll;
        hh=Table_Index(prms.reftable,r,cols[0]);
        kk=Table_Index(prms.reftable,r,cols[1]);
        ll=Table_Index(prms.reftable,r,cols[2]);
        printf("DEBUGhkl hkl: %d %d %d ki: %g %g %g q~: %g %g %g ",hh,kk,ll, vx*V2K, vy*V2K, vz*V2K,  qx,qy,qz);  
        qx=prms.sxp.asx*hh + prms.sxp.bsx*kk + prms.sxp.csx*ll;
        qy=prms.sxp.asy*hh + prms.sxp.bsy*kk + prms.sxp.csy*ll;
        qz=prms.sxp.asz*hh + prms.sxp.bsz*kk + prms.sxp.csz*ll;
        printf(" g: %g %g %g qf: %g %g %g ",g[0],g[1],g[2], qx,qy,qz);
        kfx=vx*V2K-qx;
        kfy=vy*V2K-qy;
        kfz=vz*V2K-qz;
        printf("      %g %g %g",kfx,kfy,kfz);
        
        /*adjust the weight according to the scattering factor and mosaic*/
        double f2=Table_Index(prms.reftable, r, prms.col_F2);
        printf(" f2(%d)= %g\n",r,f2);
        p*=1;//f2;

        vx=K2V*kfx;//fx;
        vy=K2V*kfy;//fy;
        vz=K2V*kfz;//fz;
        status=cylinder_intersect(&t0,&t1, x,y,z,vx,vy,vz,radius,yheight);
        //PROP_DT(t1);
        status=0;
    }
%}

MCDISPLAY
%{
  /* A bit ugly; hard-coded dimensions. */
  magnify("");
  if (prms.shape==SPHERE){
      circle("xy",0,0,0,radius);
      circle("xz",0,0,0,radius);
      circle("yz",0,0,0,radius);
  }else if (prms.shape==CYLINDER){
      circle("xz",0, yheight/2.0,0,radius);
      circle("xz",0,-yheight/2.0,0,radius);
      line(radius,yheight/2,0,radius,-yheight/2,0);
      line(-radius,yheight/2,0,-radius,-yheight/2,0);
      line(0,yheight/2,radius,0,-yheight/2,radius);
      line(0,yheight/2,-radius,0,-yheight/2,-radius);
  }else{
      box(0,0,0,xwidth,yheight,zdepth);
  }
%}
END
